<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>서로의 '결' 알아보기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto+Sans+KR', sans-serif; }
        /* 기본 카드 스타일 */
        .question-card { 
            transition: all 0.3s ease-in-out; 
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            position: relative; /* 뱃지 위치를 위해 추가 */
            padding: 2.5rem 1rem 1.5rem 1rem; /* 뱃지 공간 확보 (상단 2.5rem) */
            border-radius: 0.75rem; /* rounded-xl */
        }
        .question-card:hover { 
            transform: translateY(-5px); 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
        }
        /* 질문 유형 뱃지 (오른쪽 상단) */
        .question-type-badge {
            position: absolute;
            top: 0.75rem; /* 카드 상단에서 살짝 내림 */
            right: 0.75rem; /* 오른쪽에 위치 */
            padding: 0.25rem 0.75rem;
            font-size: 0.75rem; /* text-xs */
            font-weight: 500; /* medium */
            border-radius: 0.5rem 0 0.5rem 0; /* 테두리 모양 변경 (top-left, bottom-right) */
            border: 1px solid;
            background-clip: padding-box; /* 배경이 테두리 안쪽으로만 보이게 */
        }

        /* 동적 질문을 위한 스타일 */
        .dynamic-followup { 
            background-color: #fdfbf5; /* 아주 연한 노란색 */
            border-top: 2px dashed #fcd34d; /* yellow-400 */
            margin-top: 1rem; 
            padding: 1rem; 
            border-radius: 0.5rem;
        }
        .result-tag { background-color: #f0f0f0; color: #374151; }
        .brain-type-header { font-size: 1.125rem; font-weight: 700; margin-top: 1.5rem; margin-bottom: 0.5rem; padding-bottom: 0.5rem; }
        .male-header { border-bottom: 2px solid #93c5fd; color: #1e40af; }
        .female-header { border-bottom: 2px solid #f9a8d4; color: #9d174d; }
        details > summary { list-style: none; }
        details > summary::-webkit-details-marker { display: none; }
        /* 라디오 버튼 숨기기 */
        input[type="radio"].hidden-radio {
            display: none;
        }
        /* 커스텀 라디오 버튼 레이블 */
        label.option-label {
            display: block;
            border: 1px solid #d1d5db; /* gray-300 */
            padding: 0.75rem;
            border-radius: 0.5rem; /* rounded-lg */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: #ffffff; /* white */
        }
        /* 선택되지 않았을 때 호버 효과 */
        label.option-label:hover {
            background-color: #f9fafb; /* gray-50 */
        }
        /* 선택되었을 때 레이블 스타일 */
        input[type="radio"].hidden-radio:checked + label.option-label {
            background-color: #eef2ff; /* indigo-50 */
            border-color: #6366f1; /* indigo-500 */
            color: #3730a3; /* indigo-800 */
            font-weight: 600; /* semibold */
            box-shadow: 0 0 0 2px #c7d2fe; /* indigo-200 링 효과 */
        }
        /* 애니메이션 */
        .fade-in { animation: fadeIn 1s ease-in-out forwards; }
        .fade-in-delay-1 { animation-delay: 0.2s; }
        .fade-in-delay-2 { animation-delay: 0.4s; }
        .fade-in-delay-3 { animation-delay: 0.6s; }
        .fade-in-delay-4 { animation-delay: 0.8s; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="main-container" class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8 md:mb-12">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800">서로의 '결' 알아보기</h1>
            <p class="mt-2 text-gray-600">질문에 답하고 두 분의 고유한 '결'과 매칭률을 확인해보세요.</p>
        </header>

        <!-- 점수 계산 방식 (100점 만점) -->
        <div class="mb-8 max-w-4xl mx-auto bg-indigo-50 p-4 rounded-lg text-sm text-gray-700 border border-indigo-200">
            <details>
                <summary class="font-semibold text-center text-indigo-800 mb-2 cursor-pointer">💡 점수 계산 방식 안내 (100점 만점)</summary>
                <div class="mt-2 space-y-3">
                    <div>
                        <p class="font-semibold">💖 최종 매칭 점수 (총 100점 만점):</p>
                        <p>- '결' 모양 점수(기본) + '유사성 점수'(보너스) + '선호성 점수'(보너스)를 합산합니다.</p>
                    </div>
                    <div>
                        <p class="font-semibold">✨ '결' 모양 점수 (총점 중 70점):</p>
                        <p>- 두 분의 '결' 성향 분포(방사형 그래프)가 얼마나 비슷한지(0~100%) 계산하여, <strong>최대 70점</strong>의 기본 점수를 획득합니다.</p>
                    </div>
                    <div>
                        <p class="font-semibold">🤝 '유사성' 점수 (총점 중 15점):</p>
                        <p>- '유사성' 질문(12개)에서 두 분의 답변이 얼마나 일치하는지 계산하여, <strong>최대 15점</strong>의 보너스 점수를 획득합니다.</p>
                    </div>
                    <div>
                        <p class="font-semibold">🎯 '선호성' 점수 (총점 중 15점):</p>
                        <p>- '선호성' 질문(6개)에서 두 분이 서로 원하는 모습과 얼마나 일치하는지 계산하여, <strong>최대 15점</strong>의 보너스 점수를 획득합니다.</p>
                    </div>
                    <!-- '결' 상세 설명 -->
                    <div id="group-descriptions" class="space-y-3 text-xs mt-4 pt-4 border-t border-indigo-200">
                        <p class="font-semibold text-sm text-indigo-800">※ 6가지 성향 그룹 (결)</p>
                        <!-- Descriptions will be injected here by JS -->
                    </div>
                </div>
            </details>
        </div>

        <!-- '결' 모양 점수 계산 상세 -->
        <div class="mb-8 max-w-4xl mx-auto bg-green-50 p-4 rounded-lg text-sm text-gray-700 border border-green-200">
            <details>
                <summary class="font-semibold text-center text-green-800 mb-2 cursor-pointer">📈 '결' 모양 점수 (70점) 계산 상세 (클릭)</summary>
                <div class="mt-2 space-y-3">
                    <p>'결' 모양 점수는 <strong>총점의 70%</strong>를 차지하는 가장 중요한 기본 점수입니다. 계산 과정은 다음과 같습니다.</p>
                    <ol class="list-decimal list-inside space-y-2">
                        <li>
                            <strong>'결'별 답변 수 집계:</strong><br>
                            두 분이 '나의 모습'으로 답한 18개 질문을 6가지 '결'로 분류하여 개수를 셉니다.
                        </li>
                        <li>
                            <strong>'결'별 답변 비율(%) 계산:</strong><br>
                            18개의 답변 중 각 '결'이 몇 %의 비중을 차지하는지 계산합니다. (방사형 그래프 모양)
                        </li>
                        <li>
                            <strong>두 분의 '결' 비율 비교 (핵심):</strong><br>
                            두 분의 '결' 비율(%)을 1:1로 비교하여, <strong>둘 중 더 낮은 값</strong>을 가져옵니다. (그래프가 겹치는 영역)
                        </li>
                        <li>
                            <strong>'결 모양 유사도' (0~100%) 계산:</strong><br>
                            3번에서 찾은 '겹치는 영역'을 6가지 '결'에 대해 모두 더합니다. 이 합계가 두 분의 '결 모양 유사도'입니다.
                        </li>
                        <li>
                            <strong>최종 점수 환산 (최대 70점):</strong><br>
                            '결 모양 유사도'(%)에 <strong>최대 배점인 70점</strong>을 곱하여 최종 '결 모양 점수'를 도출합니다.<br>
                            <span class="text-xs text-gray-600"> (예: 유사도 85% 시 -> 0.85 * 70점 = 59.5점 획득)</span>
                        </li>
                    </ol>
                </div>
            </details>
        </div>
        
        <!-- (NEW) 유사성/선호성 점수 계산 상세 -->
        <div class="mb-8 max-w-4xl mx-auto bg-yellow-50 p-4 rounded-lg text-sm text-gray-700 border border-yellow-200" id="bonus-score-details">
            <details>
                <summary class="font-semibold text-center text-yellow-800 mb-2 cursor-pointer">📊 보너스 점수 (30점) 계산 상세 (클릭)</summary>
                <div class="mt-2 space-y-3">
                    <p>보너스 점수는 두 분이 서로 얼마나 일치하고(유사성), 서로에게 맞춰주는지(선호성)를 봅니다.</p>
                    <div class="pt-2">
                        <p class="font-semibold">🤝 '유사성' 보너스 (최대 15점)</p>
                        <p>- 12개의 '유사성' 질문을 통해 <strong>최대 72점</strong>의 원점수를 획득한 뒤, 15점 만점으로 환산합니다.</p>
                        <ul class="list-disc list-inside text-xs text-gray-600 pl-2">
                            <li><strong>완전 일치 (6점):</strong> 두 분의 답변이 정확히 일치</li>
                            <li><strong>성향 일치 (5점):</strong> 답변은 다르나, 같은 '성향 그룹(결)'에 속함</li>
                        </ul>
                    </div>
                    <div class="pt-2">
                        <p class="font-semibold">🎯 '선호성' 보너스 (최대 15점)</p>
                        <p>- 6개의 '선호성' 질문을 통해 <strong>최대 102점</strong>의 원점수를 획득한 뒤, 15점 만점으로 환산합니다.</p>
                        <p class="font-medium text-xs text-gray-700 pt-1 pl-2">1. (교차) 질문 (3문항 x 양방향 = 6회)</p>
                        <ul class="list-disc list-inside text-xs text-gray-600 pl-4">
                            <li><strong>완전 일치 (12점):</strong> [나의 선호]와 [파트너의 실제] 답변이 정확히 일치</li>
                            <li><strong>성향 일치 (8점):</strong> 답변은 다르나, 같은 '성향 그룹(결)'에 속함</li>
                        </ul>
                        <p class="font-medium text-xs text-gray-700 pt-1 pl-2">2. (동적) 질문 (3문항 x 심도 비교 = 3회)</p>
                        <ul class="list-disc list-inside text-xs text-gray-600 pl-4">
                            <li><strong>심도 완전 일치 (10점):</strong> (예: 둘 다 '심도 1' 선택)</li>
                            <li><strong>심도 1칸 차이 (8점):</strong> (예: '심도 1' vs '심도 2')</li>
                            <li><strong>심도 2칸 차이 (6점):</strong> (예: '심도 1' vs '심도 3')</li>
                            <li><strong>심도 3칸 차이 (4점):</strong> (예: '심도 1' vs 'any')</li>
                        </ul>
                    </div>
                </div>
            </details>
        </div>


        <div id="question-section">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div class="bg-blue-50 p-6 rounded-xl shadow-lg">
                    <h2 class="text-2xl font-bold text-center mb-6 text-blue-800">🤵‍♂️ 남자</h2>
                    <div id="male-questions" class="space-y-6"></div>
                </div>
                <div class="bg-pink-50 p-6 rounded-xl shadow-lg">
                    <h2 class="text-2xl font-bold text-center mb-6 text-pink-800">👰‍♀️ 여자</h2>
                    <div id="female-questions" class="space-y-6"></div>
                </div>
            </div>
            <div class="text-center mt-8">
                <div id="warning-message" class="mb-4 text-center text-red-500 font-semibold hidden">
                    모든 질문에 답변해주세요! (노란색 동적 질문 포함)
                </div>
                <button id="random-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-full text-lg transition-transform transform hover:scale-105 shadow-lg mr-4">
                    랜덤으로 답변하기
                </button>
                <button id="calculate-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-8 rounded-full text-lg transition-transform transform hover:scale-105 shadow-lg">
                    결과 확인하기
                </button>
            </div>
        </div>

        <div id="results" class="hidden mt-8 md:mt-12 bg-white p-8 rounded-2xl shadow-2xl text-center">
            <h2 class="text-3xl md:text-4xl font-bold text-gray-800 opacity-0 fade-in">최종 결과</h2>
            
            <div class="my-8 opacity-0 fade-in fade-in-delay-1">
                <p class="text-lg text-gray-600">두 분의 가치관 매칭 점수는...</p>
                <p id="matching-score" class="text-6xl font-extrabold text-indigo-500 my-4">0점</p>
                <p class="text-sm text-gray-500">(100점 만점)</p>
                <div class="w-full bg-gray-200 rounded-full h-4 max-w-lg mx-auto mt-2">
                    <div id="score-bar" class="bg-indigo-500 h-4 rounded-full transition-all duration-1000 ease-out" style="width: 0%"></div>
                </div>
                
                <!-- (수정) 100점 만점 환산 점수 표시 -->
                <div class="flex justify-center gap-4 mt-6 max-w-lg mx-auto">
                    <div class="flex-1 text-center p-3 bg-green-50 rounded-lg">
                        <p class="font-semibold text-gray-700">✨ '결' 모양</p>
                        <p id="shape-score" class="text-2xl font-bold text-green-600">0점</p>
                    </div>
                    <div class="flex-1 text-center p-3 bg-blue-50 rounded-lg">
                        <p class="font-semibold text-gray-700">🤝 유사성</p>
                        <p id="similarity-score" class="text-2xl font-bold text-blue-600">0점</p>
                    </div>
                    <div class="flex-1 text-center p-3 bg-pink-50 rounded-lg">
                        <p class="font-semibold text-gray-700">🎯 선호성</p>
                        <p id="preference-score" class="text-2xl font-bold text-pink-600">0점</p>
                    </div>
                </div>
                <p class="text-xs text-gray-400 mt-2">(각 100점 만점 환산 / 총점은 (결 70 + 유 15 + 선 15)로 계산)</p>
            </div>

            <!-- 상세 점수 분석 -->
            <div class="mt-8 pt-6 border-t opacity-0 fade-in fade-in-delay-2">
                <h3 class="text-2xl font-bold text-gray-800 mb-4">📈 '결'별 상세 분석</h3>
                <p class="text-gray-600 text-sm mb-4">(※ '나의 모습'으로 답한 성향의 분포입니다)</p>
                <div id="score-breakdown" class="max-w-3xl mx-auto text-left space-y-4"></div>
            </div>

            <div class="mt-8 pt-6 border-t opacity-0 fade-in fade-in-delay-3">
                <h3 class="text-2xl font-bold text-gray-800 mb-4">✨ 우리의 종합 '결'</h3>
                <div id="combined-gradient" class="w-full h-32 md:h-40 rounded-2xl flex items-center justify-center relative overflow-hidden shadow-inner">
                     <p id="gradient-text" class="text-white text-3xl font-bold" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">Our Vibe</p>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mt-8 opacity-0 fade-in fade-in-delay-4">
                <!-- 남자 결과 -->
                <div class="bg-white p-6 rounded-xl shadow-lg border">
                    <p class="text-gray-600 font-semibold">🤵‍♂️ 남자의 '결'은...</p>
                    <div id="result-visual-male" class="mt-4 p-6 rounded-lg transition-all duration-500">
                        <h3 id="result-profile-text-male" class="text-2xl font-extrabold text-white" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.4);"></h3>
                    </div>
                    <div class="mt-4 text-left">
                        <p id="result-group-name-male" class="font-bold text-lg text-gray-800"></p>
                        <p id="result-group-description-male" class="text-gray-600 mt-1 text-sm"></p>
                    </div>
                </div>
                <!-- 여자 결과 -->
                <div class="bg-white p-6 rounded-xl shadow-lg border">
                    <p class="text-gray-600 font-semibold">👰‍♀️ 여자의 '결'은...</p>
                    <div id="result-visual-female" class="mt-4 p-6 rounded-lg transition-all duration-500">
                        <h3 id="result-profile-text-female" class="text-2xl font-extrabold text-white" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.4);"></h3>
                    </div>
                    <div class="mt-4 text-left">
                        <p id="result-group-name-female" class="font-bold text-lg text-gray-800"></p>
                        <p id="result-group-description-female" class="text-gray-600 mt-1 text-sm"></p>
                    </div>
                </div>
            </div>

            <div class="mt-8 pt-6 border-t opacity-0 fade-in fade-in-delay-4">
                <h3 class="text-xl font-bold text-gray-800 mb-4">💌 두 분의 관계 조언</h3>
                <p id="relationship-advice" class="text-gray-700 bg-gray-100 p-4 rounded-lg"></p>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8 pt-6 border-t opacity-0 fade-in fade-in-delay-4">
                 <div>
                    <h3 class="text-lg font-bold text-gray-800 mb-4">남자의 상세 성향 태그</h3>
                    <div id="male-tags" class="flex flex-wrap gap-2 justify-center"></div>
                </div>
                <div>
                    <h3 class="text-lg font-bold text-gray-800 mb-4">여자의 상세 성향 태그</h3>
                    <div id="female-tags" class="flex flex-wrap gap-2 justify-center"></div>
                </div>
            </div>

            <div class="mt-12 opacity-0 fade-in fade-in-delay-4">
                 <button id="retry-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-3 px-8 rounded-full text-lg">
                    다시하기
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. 데이터 구조 정의 ---
        
        const questions = [
            // --- 1) Action (나의 행동 유형) ---
            {
                id: 'q1',
                type: 'similarity', // 유형: 유사성
                brainType: 'Action (나의 행동 유형)',
                text: '인스타그램 스토리에 사진을 올린다면 어떤 사진을 선택하시겠어요?',
                options: [
                     { value: 'experience', text: '아름다운 자연경관에서 찍은 내 사진 (경험중시형)', tag: '#경험중시형'},
                     { value: 'achievement', text: '미슐랭 5스타 고급 레스토랑의 음식 사진 (성취지향형)', tag: '#성취지향형'},
                     { value: 'social', text: '친구들과 함께 파티를 즐기는 역동적인 사진 (사교형)', tag: '#사교형'},
                     { value: 'stability', text: '인스타그램 스토리는 잘 올리지 않는 편 (안정지향형)', tag: '#안정지향형'}
                 ]
            },
            {
                id: 'q2',
                type: 'similarity', // 유형: 유사성
                brainType: 'Action (나의 행동 유형)',
                text: '선호하는 운동 스타일은 무엇인가요?',
                options: [
                     { value: 'self', text: '혼자 집중하며 즐기는 운동 (러닝, 헬스 등) (자기계발형)', tag: '#자기계발형'},
                     { value: 'team', text: '파트너나 팀과 함께하는 운동 (테니스, 축구 등) (활동적인)', tag: '#활동적인'},
                     { value: 'none', text: '운동은 별로 즐기지 않음 (정적인)', tag: '#정적인'}
                 ]
            },
            {
                id: 'q22',
                type: 'dynamic', // 유형: 선호성 (동적)
                brainType: 'Action (나의 행동 유형)',
                text: '당신의 이상적인 주말은 어떤 모습에 가까운가요?',
                options: [
                    { 
                        value: 'introvert', text: '집에서 편안하게 휴식을 취하며 재충전 (집순이/집돌이)', tag: '#집순이/집돌이',
                        followup: {
                            text: '연인은 어떤 주말을 선호하길 바라나요?',
                            options: [
                                { value: '1', text: '나처럼 집에서 조용히 쉬는 사람 (심도 1)' },
                                { value: '2', text: '가끔은 같이 나가서 활동적인 데이트를 하는 사람 (심도 2)' },
                                { value: '3', text: '나는 쉬더라도, 연인은 밖에서 즐겁게 놀다 와도 OK (심도 3)' },
                                { value: '4', text: '딱히 상관없음 (any)' } // 심도 4로 간주
                            ]
                        }
                    },
                    { 
                        value: 'developer', text: '새로운 것을 배우거나 취미 활동에 몰두 (자기계발형)', tag: '#자기계발형',
                        followup: {
                            text: '연인은 어떤 주말을 선호하길 바라나요?',
                            options: [
                                { value: '1', text: '나처럼 자기계발을 하거나, 최소한 방해하지 않는 사람 (심도 1)' },
                                { value: '2', text: '함께 공통의 취미나 배움을 즐길 수 있는 사람 (심도 2)' },
                                { value: '3', text: '주말엔 일/배움과 분리되어 편안하게 쉬는 사람 (심도 3)' },
                                { value: '4', text: '딱히 상관없음 (any)' }
                            ]
                        }
                    },
                    { 
                        value: 'social', text: '친구들을 만나거나 새로운 사람들과 어울림 (사교형)', tag: '#사교형',
                        followup: {
                            text: '연인은 어떤 주말을 선호하길 바라나요?',
                            options: [
                                { value: '1', text: '나의 사교 활동을 존중해주고 가끔 함께 어울리는 사람 (심도 1)' },
                                { value: '2', text: '나와 함께 어울리는 것을 즐기는 E성향의 사람 (심도 2)' },
                                { value: '3', text: '연인과는 별개. 연인은 집에서 쉬는 등 조용한 사람 선호 (심도 3)' },
                                { value: '4', text: '딱히 상관없음 (any)' }
                            ]
                        }
                    },
                    { 
                        value: 'adventure', text: '가까운 곳으로 여행을 떠나 새로운 경험 (모험추구형)', tag: '#모험추구형',
                        followup: {
                            text: '연인은 어떤 주말을 선호하길 바라나요?',
                            options: [
                                { value: '1', text: '나와 함께 여행과 모험을 즐기는 사람 (심도 1)' },
                                { value: '2', text: '여행은 좋지만, 가끔은 집에서 쉬기도 하는 사람 (심도 2)' },
                                { value: '3', text: '나는 여행을 가더라도, 연인은 집에서 쉬는 등 안정적인 사람 선호 (심도 3)' },
                                { value: '4', text: '딱히 상관없음 (any)' }
                            ]
                        }
                    }
                ]
            },

            // --- 2) Emotion (나의 감정 및 관계 유형) ---
            {
                id: 'q4',
                type: 'similarity', // 유형: 유사성
                brainType: 'Emotion (나의 감정 및 관계 유형)',
                text: '꿈꾸는 프러포즈는 어떤 모습인가요?',
                options: [
                     { value: 'romantic', text: '분위기 좋은 레스토랑에서의 로맨틱한 프러포즈 (낭만주의형)', tag: '#낭만주의형'},
                     { value: 'event', text: '많은 사람들 앞에서의 깜짝 프러포즈 (이벤트선호)', tag: '#이벤트선호'},
                     { value: 'memory', text: '둘만의 추억이 담긴 장소에서의 진솔한 프러포즈 (관계중심형)', tag: '#관계중심형'},
                     { value: 'practical', text: '화려함보다 진심이 담긴 반지와 편지 (실용주의형)', tag: '#실용주의형'}
                 ]
            },
            {
                id: 'q5',
                type: 'similarity', // 유형: 유사성
                brainType: 'Emotion (나의 감정 및 관계 유형)',
                text: '연인이 했을 때 가장 설레는 행동은 무엇인가요?',
                options: [
                     { value: 'detail', text: '내가 했던 말을 기억하고 세심하게 챙겨줄 때 (세심함중시)', tag: '#세심함중시'},
                     { value: 'skinship', text: '힘든 하루 끝에 말없이 꼭 안아줄 때 (스킨십중시)', tag: '#스킨십중시'},
                     { value: 'support', text: '나의 일이나 성과를 진심으로 응원하고 지지해줄 때 (정서적지지)', tag: '#정서적지지'},
                     { value: 'time', text: '함께 시간을 보낼 때 나에게 온전히 집중해줄 때 (시간공유형)', tag: '#시간공유형'}
                 ]
            },
             {
                id: 'q23',
                type: 'dynamic', // 유형: 선호성 (동적)
                brainType: 'Emotion (나의 감정 및 관계 유형)',
                text: '공공장소에서의 애정표현(스킨십)에 대해 어떻게 생각하시나요?',
                options: [
                     { 
                        value: 'conservative', text: '손 잡는 것 정도는 괜찮지만, 그 이상은 조심스러움 (보수적가치관)', tag: '#보수적가치관',
                        followup: {
                            text: '연인이 나보다 스킨십에 개방적이라면?',
                            options: [
                                { value: '1', text: '연인에게 맞춰주려고 노력함 (심도 1)' },
                                { value: '2', text: '서로 조율하며 합의점을 찾음 (심도 2)' },
                                { value: '3', text: '단호하게 안된다고 말함 (심도 3)' },
                                { value: '4', text: '딱히 상관없음 (any)' }
                            ]
                        }
                    },
                     { 
                        value: 'liberal', text: '주변에 피해만 주지 않는다면 자유롭게 표현 가능 (자유로운표현)', tag: '#자유로운표현',
                        followup: {
                            text: '연인이 나보다 스킨십에 보수적이라면?',
                            options: [
                                { value: '1', text: '연인에게 맞춰주려고 노력함 (심도 1)' },
                                { value: '2', text: '서로 조율하며 합의점을 찾음 (심도 2)' },
                                { value: '3', text: '답답하지만, 연인이 원할 때까지 기다림 (심도 3)' },
                                { value: '4', text: '딱히 상관없음 (any)' }
                            ]
                        }
                    },
                     { 
                        value: 'private', text: '애정표현은 둘만 있는 사적인 공간에서 하는 것이 좋음 (사생활중시)', tag: '#사생활중시',
                        followup: {
                            text: '연인이 공공장소에서 스킨십을 시도한다면?',
                            options: [
                                { value: '1', text: '일단 받아주지만, 나중에 따로 이야기함 (심도 1)' },
                                { value: '2', text: '가볍게 피하거나, 장소를 옮기자고 제안함 (심도 2)' },
                                { value: '3', text: '그 자리에서 단호하게 거부 의사를 표현함 (심도 3)' },
                                { value: '4', text: '딱히 상관없음 (any)' }
                            ]
                        }
                    },
                     { 
                        value: 'adaptive', text: '장소와 분위기에 따라 유연하게 달라질 수 있음 (상황적응형)', tag: '#상황적응형',
                        followup: {
                            text: '연인이 TPO에 맞지 않는 스킨십을 시도한다면?',
                            options: [
                                { value: '1', text: '일단 받아주지만, 나중에 따로 이야기함 (심도 1)' },
                                { value: '2', text: '눈치를 주거나, 장난스럽게 타이름 (심도 2)' },
                                { value: '3', text: '그 자리에서 바로 제지함 (심도 3)' },
                                { value: '4', text: '딱히 상관없음 (any)' }
                            ]
                        }
                    }
                 ]
            },
            {
                id: 'q26',
                type: 'crossover', // 유형: 선호성 (교차)
                brainType: 'Emotion (나의 감정 및 관계 유형)',
                text_me: '비 오는 날, 퇴근 시간에 맞춰 연인이 회사 앞에 우산을 들고 나타났습니다. 당신의 반응은?',
                text_partner: '이런 상황에서, 파트너가 어떻게 반응해주길 바라나요?',
                options: [
                     { value: 'expressive', text: '우와, 어떻게 알고 왔어? 와줘서 정말 고마워! (감정표현형)', tag: '#감정표현형'},
                     { value: 'caring', text: '괜찮은데 왜 고생스럽게 왔어~ 걱정되잖아 (배려형)', tag: '#배려형'},
                     { value: 'romantic', text: '마침 보고 싶었는데, 이렇게 깜짝으로 보니 더 좋다! (낭만주의형)', tag: '#낭만주의형'},
                     { value: 'practical', text: '잘 왔다! 이왕 만났으니 맛있는 거 먹으러 갈까? (실용주의형)', tag: '#실용주의형'}
                 ]
            },
            {
                id: 'q17',
                type: 'similarity', // 유형: 유사성
                brainType: 'Emotion (나의 감정 및 관계 유형)',
                text: '내 연인이 내 친구의 깻잎을 떼주는 것을 보았습니다. 당신의 생각은?',
                options: [
                     { value: 'cool', text: '아무렇지 않음. 그럴 수 있음 (쿨한연애)', tag: '#쿨한연애'},
                     { value: 'control', text: '기분은 좀 그렇지만 티 내지 않음 (감정조절형)', tag: '#감정조절형'},
                     { value: 'talk', text: '연인에게 장난스럽게 서운함을 표현함 (관계중심형)', tag: '#관계중심형'},
                     { value: 'no', text: '절대 안됨. 그 자리에서 이야기함 (원칙주의형)', tag: '#원칙주의형'}
                 ]
            },
            {
                id: 'q18',
                type: 'similarity', // 유형: 유사성
                brainType: 'Emotion (나의 감정 및 관계 유형)',
                text: '선호하는 반려동물이 있나요?',
                options: [
                     { value: 'dog', text: '활동적이고 애교 많은 강아지가 좋음 (활동적인)', tag: '#활동적인'},
                     { value: 'cat', text: '독립적이고 차분한 고양이가 좋음 (차분한)', tag: '#차분한'},
                     { value: 'realist', text: '둘 다 좋지만, 키울 자신은 없음 (현실주의형)', tag: '#현실주의형'},
                     { value: 'none', text: '반려동물을 키우는 것은 선호하지 않음 (개인주의형)', tag: '#개인주의형'}
                 ]
            },
            // --- 3) Thinking (나의 가치관 및 생각 유형) ---
            {
                id: 'q11',
                type: 'similarity', // 유형: 유사성
                brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text: '성공한 친구가 확실한 투자처라며 주식 정보를 주었습니다. 어떻게 하시겠어요?',
                options: [
                     { value: 'allin', text: '친구를 믿고 \'영끌\' 대출을 해서 투자 (과감한투자)', tag: '#과감한투자'},
                     { value: 'cash', text: '현재 보유한 현금 전부를 투자 (공격적투자)', tag: '#공격적투자'},
                     { value: 'half', text: '여유 자금의 절반 정도만 신중하게 투자 (안정적투자)', tag: '#안정적투자'},
                     { value: 'none', text: '스스로 분석 없이는 투자하지 않음 (원칙주의형)', tag: '#원칙주의형'}
                 ]
            },
             {
                id: 'q19',
                type: 'crossover', // 유형: 선호성 (교차)
                brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text_me: '연인과 갈등이 생겼을 때, 당신은 어떻게 해결하나요?',
                text_partner: '연인과 갈등이 생겼을 때, 파트너가 어떻게 해결해주길 바라나요?',
                options: [
                     { value: 'logic', text: '감정이 가라앉을 때까지 기다렸다가 차분히 대화 (논리적대화)', tag: '#논리적대화'},
                     { value: 'avoid', text: '갈등이 길어지는게 싫어 빨리 사과하고 넘어감 (갈등회피형)', tag: '#갈등회피형'},
                     { value: 'express', text: '감정을 솔직하게 모두 표현해야 직성이 풀림 (감정표현형)', tag: '#감정표현형'},
                     { value: 'solve', text: '함께 문제를 분석하고 해결책을 찾으려 노력함 (문제해결형)', tag: '#문제해결형'}
                 ]
            },
            {
                id: 'q27',
                type: 'crossover', // 유형: 선호성 (교차)
                brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text_me: '배우자가 청소기를 돌렸는데 구석에 먼지가 그대로 있습니다. 당신의 반응은?',
                text_partner: '만약 당신이 청소기를 돌렸는데 구석에 먼지가 있다면, 파트너가 어떻게 반응해주길 바라나요?',
                 options: [
                     { value: 'praise', text: '우와, 청소해줬네! 정말 고마워~ (긍정적강화)', tag: '#긍정적강화'},
                     { value: 'feedback', text: '고마워! 다음엔 이쪽 구석도 한번 더 신경 써주면 완벽할 것 같아! (피드백제공)', tag: '#피드백제공'},
                     { value: 'avoid', text: '말없이 내가 직접 나머지 먼지를 청소함 (갈등회피형)', tag: '#갈등회피형'},
                     { value: 'yolo', text: '그 정도는 괜찮음. 신경 쓰지 않음 (YOLO)', tag: '#YOLO'}
                 ]
            },
            {
                id: 'q24',
                type: 'similarity', // 유형: 유사성
                brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text: '결혼 후 양가 부모님 댁 방문 빈도는 어느 정도가 적당하다고 생각하시나요?',
                options: [
                     { value: 'holiday', text: '명절이나 생신 등 특별한 날에만 방문 (독립성중시)', tag: '#독립성중시'},
                     { value: 'monthly', text: '한두 달에 한 번 정도는 정기적으로 방문 (가족중심형)', tag: '#가족중심형'},
                     { value: 'free', text: '정해진 것 없이, 필요하거나 원할 때 자유롭게 왕래 (자유추구형)', tag: '#자유추구형'},
                     { value: 'close', text: '가까이 살면서 자주 왕래하며 가깝게 지냄 (관계중심형)', tag: '#관계중심형'}
                 ]
            },
             {
                id: 'q25',
                type: 'dynamic', // 유형: 선호성 (동적)
                brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text: '가사(집안일) 분담에 대한 당신의 생각은?',
                options: [
                     { 
                        value: 'efficient', text: '각자 잘하는 일을 정해서 명확하게 역할을 나눔 (효율중시형)', tag: '#효율중시형',
                        followup: {
                            text: '만약 상대방이 자신의 역할을 제대로 하지 않는다면?',
                            options: [
                                { value: '1', text: '즉시 피드백하고 다시 역할을 조율함 (심도 1)' },
                                { value: '2', text: '몇 번 참고 기다리다가 좋게 이야기함 (심도 2)' },
                                { value: '3', text: '그냥 내가 참고 해버림 (심도 3)' },
                                { value: '4', text: '딱히 상관없음 (any)' }
                            ]
                        }
                    },
                     { 
                        value: 'autonomy', text: '정해놓지 않고, 시간이 되거나 먼저 보는 사람이 함 (자율형)', tag: '#자율형',
                        followup: {
                            text: '만약 나만 계속 집안일을 하게 된다면?',
                            options: [
                                { value: '2', text: '기분이 나쁨, 결국 역할을 정하자고 말함 (심도 2)' }, // '심도 2'
                                { value: '1', text: '눈치껏 상대방도 하길 바람 (심도 1)' }, // '심도 1'
                                { value: '3', text: '상관없음, 내가 더 깔끔하니 내가 함 (심도 3)' },
                                { value: '4', text: '딱히 상관없음 (any)' }
                            ]
                        }
                    },
                     { 
                        value: 'plan', text: '주말 등 특정 시간을 정해 함께 집중적으로 처리 (계획형)', tag: '#계획형',
                        followup: {
                            text: '만약 상대방이 계획된 시간에 자꾸 딴짓을 한다면?',
                            options: [
                                { value: '1', text: '계획대로 하자고 단호하게 말함 (심도 1)' },
                                { value: '2', text: '기다려주되, 빨리 끝내자고 재촉함 (심도 2)' },
                                { value: '3', text: '어쩔 수 없음. 나중에 하거나 내가 먼저 함 (심도 3)' },
                                { value: '4', text: '딱히 상관없음 (any)' }
                            ]
                        }
                    },
                     { 
                        value: 'system', text: '가사도우미, 식기세척기 등 시스템을 적극 활용 (편리성추구)', tag: '#편리성추구',
                        followup: {
                            text: '만약 상대방이 시스템 활용에 돈 아까워 한다면?',
                            options: [
                                { value: '1', text: '편리함과 시간의 가치를 설득함 (심도 1)' },
                                { value: '2', text: '상대방을 설득하되, 일부만 사용하며 합의함 (심도 2)' },
                                { value: '3', text: '상대방 의견을 존중하여 사용하지 않음 (심도 3)' },
                                { value: '4', text: '딱히 상관없음 (any)' }
                            ]
                        }
                    }
                 ]
            },
            {
                id: 'q12',
                type: 'similarity', // 유형: 유사성
                brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text: '이상적인 자녀 수는 몇 명인가요?',
                options: [
                     { value: 'dink', text: '딩크(DINK)족, 자녀 없이 둘만의 삶 (개인주의형)', tag: '#개인주의형'},
                     { value: 'one', text: '한 명의 자녀에게 집중 (계획형)', tag: '#계획형'},
                     { value: 'two', text: '안정적이고 화목한 두 명의 자녀 (가정중심형)', tag: '#가정중심형'},
                     { value: 'many', text: '다둥이 가정을 꿈꿈 (다자녀선호)', tag: '#다자녀선호'}
                 ]
            },
            {
                id: 'q13',
                type: 'similarity', // 유형: 유사성
                brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text: '선호하는 부부의 경제 활동 형태는 무엇인가요?',
                options: [
                     { value: 'dual', text: '각자의 커리어를 존중하는 맞벌이 (성장지향형)', tag: '#성장지향형'},
                     { value: 'flexible', text: '상황에 따라 유연하게, 가능하면 맞벌이 (상황적응형)', tag: '#상황적응형'},
                     { value: 'single', text: '한 사람은 경제활동, 한 사람은 가정을 돌보는 외벌이 (전통적가치관)', tag: '#전통적가치관'},
                     { value: 'free', text: '경제적 여유만 있다면, 자유롭게 살고 싶음 (자유추구형)', tag: '#자유추구형'}
                 ]
            },
            {
                id: 'q15',
                type: 'similarity', // 유형: 유사성
                brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text: '당신이 결혼을 원하는 가장 큰 이유는 무엇인가요?',
                options: [
                     { value: 'stability', text: '정서적 안정감과 평생의 동반자를 얻기 위해 (안정지향형)', tag: '#안정지향형'},
                     { value: 'family', text: '사랑하는 사람과 가정을 꾸리기 위해 (가정중심형)', tag: '#가정중심형'},
                     { value: 'growth', text: '더 나은 미래를 함께 계획하고 성장하기 위해 (성장지향형)', tag: '#성장지향형'},
                     { value: 'fun', text: '함께 다양한 경험을 하며 인생을 더 즐겁게 살기 위해 (모험추구형)', tag: '#모험추구형'}
                 ]
            },
            {
                id: 'q16',
                type: 'similarity', // 유형: 유사성
                brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text: '신혼집을 구한다면, 당신의 우선순위는 어디에 있나요?',
                options: [
                     { value: 'future', text: '미래 가치를 보고 서울 중심지 아파트 선택 (미래가치중시)', tag: '#미래가치중시'},
                     { value: 'present', text: '현재의 안정을 위해 경기도 신축 아파트 선택 (현재안정중시)', tag: '#현재안정중시'},
                     { value: 'location', text: '직주근접이 가장 중요함 (실용주의형)', tag: '#실용주의형'},
                     { value: 'interior', text: '개인의 취향이 담긴 인테리어의 집을 원함 (심미주의형)', tag: '#심미주의형'}
                 ]
            }
        ];
                
        // (이하 태그 그룹, 프로필, 단어 정의는 원본과 동일)
        const tagGroups = {
            EMOTIONAL_CONNECT: { tags: ['#낭만주의형', '#관계중심형', '#세심함중시', '#스킨십중시', '#정서적지지', '#배려형', '#감정표현형', '#긍정적강화', '#가족중심형', '#다자녀선호', '#시간공유형'] },
            PRACTICAL_RATIONAL: { tags: ['#실용주의형', '#원칙주의형', '#현실주의형', '#논리적대화', '#문제해결형', '#효율중시형', '#피드백제공', '#미래가치중시'] },
            STABILITY_ORIENTED: { tags: ['#안정지향형', '#안정적투자', '#계획형', '#집순이/집돌이', '#보수적가치관', '#현재안정중시', '#전통적가치관', '#정적인'] },
            ACTIVE_EXPERIENCE: { tags: ['#경험중시형', '#성취지향형', '#사교형', '#활동적인', '#모험추구형', '#이벤트선호', '#과감한투자', '#공격적투자', '#자기계발형', '#성장지향형'] },
            AUTONOMY_FLEXIBILITY: { tags: ['#개인주의형', '#쿨한연애', '#자유로운표현', '#사생활중시', '#자유추구형', '#독립성중시', '#자율형', '#갈등회피형', '#YOLO'] }, // #YOLO 추가
            ADAPTIVE_BALANCED: { tags: ['#상황적응형', '#감정조절형', '#편리성추구', '#심미주의형', '#차분한'] }
        };

        const sensoryProfiles = {
            EMOTIONAL_CONNECT: { name: "감성의 결", description: "사람들과의 따뜻한 유대와 감정적 교류에서 행복을 느끼는 사람입니다. 타인의 마음에 깊이 공감하며, 관계를 통해 안정감을 얻는 섬세한 '결'을 가졌습니다.", background: "bg-pink-400", colorCode: "#F9A8D4" },
            PRACTICAL_RATIONAL: { name: "이성의 결", description: "명확한 논리와 효율성을 중요하게 생각하며, 문제 해결에 뛰어난 능력을 보입니다. 감정보다 이성적인 판단을 우선시하는 시원하고 투명한 '결'을 가졌습니다.", background: "bg-blue-500", colorCode: "#3B82F6" },
            STABILITY_ORIENTED: { name: "안정의 결", description: "예측 가능하고 편안한 환경에서 가장 큰 안정감을 느낍니다. 꾸준함과 신뢰를 바탕으로 삶을 단단하게 가꾸어 나가는 차분하고 깊은 '결'을 가졌습니다.", background: "bg-green-500", colorCode: "#22C55E" },
            ACTIVE_EXPERIENCE: { name: "활동의 결", description: "새로운 도전과 경험을 통해 삶의 에너지를 얻는 열정적인 사람입니다. 끊임없이 성장하고 세상을 탐험하고자 하는 반짝이는 '결'을 가졌습니다.", background: "bg-amber-500", colorCode: "#F59E0B" },
            AUTONOMY_FLEXIBILITY: { name: "자유의 결", description: "자신만의 고유한 개성과 자유를 무엇보다 중요하게 생각합니다. 정해진 틀에 얽매이지 않고, 자신만의 속도와 방식으로 세상을 살아가는 신비로운 '결'을 가졌습니다.", background: "bg-purple-500", colorCode: "#8B5CF6" },
            ADAPTIVE_BALANCED: { name: "조화의 결", description: "어떤 상황에서도 유연하게 대처하며, 갈등보다는 조화를 추구합니다. 치우치지 않는 균형감각으로 주변과 자연스럽게 어우러지는 맑고 깨끗한 '결'을 가졌습니다.", background: "bg-gray-500", colorCode: "#6B7280" }
        };
        const sensoryWords = {
            EMOTIONAL_CONNECT: { texture: ["따뜻한", "부드러운", "포근한"], color: ["핑크빛", "복숭아빛"], scent: ["꽃향기", "달콤한 과일향"], shape: ["솜사탕", "실크 스카프", "구름"] },
            PRACTICAL_RATIONAL: { texture: ["시원한", "매끄러운", "단단한"], color: ["하늘색", "회색빛"], scent: ["비 냄새", "민트향"], shape: ["수정", "유리구슬", "얼음 조각"] },
            STABILITY_ORIENTED: { texture: ["단단한", "차분한", "편안한"], color: ["연두색", "갈색빛"], scent: ["나무향", "젖은 흙냄새"], shape: ["조약돌", "나뭇잎", "이끼"] },
            ACTIVE_EXPERIENCE: { texture: ["뜨거운", "톡톡 튀는", "짜릿한"], color: ["노란색", "주황색"], scent: ["상큼한 레몬향", "타오르는 장작 냄새"], shape: ["별", "불꽃", "보석 원석"] },
            AUTONOMY_FLEXIBILITY: { texture: ["신비로운", "오묘한", "가벼운"], color: ["보랏빛", "남색"], scent: ["깊은 밤공기 냄새", "고요한 숲의 향"], shape: ["안개", "자수정", "깃털"] },
            ADAPTIVE_BALANCED: { texture: ["깨끗한", "맑은", "투명한"], color: ["흰색", "투명한"], scent: ["무향(無香)", "맑은 공기 냄새"], shape: ["물방울", "이슬", "백자"] }
        };

        // --- 2. DOM 요소 정의 ---
        const maleQuestionsContainer = document.getElementById('male-questions');
        const femaleQuestionsContainer = document.getElementById('female-questions');
        const calculateBtn = document.getElementById('calculate-btn');
        const randomBtn = document.getElementById('random-btn');
        const resultsContainer = document.getElementById('results');
        const warningMessage = document.getElementById('warning-message');
        const questionSection = document.getElementById('question-section');
        const retryBtn = document.getElementById('retry-btn');
        const combinedGradientEl = document.getElementById('combined-gradient');
        const groupDescriptionsEl = document.getElementById('group-descriptions');

        const matchingScoreEl = document.getElementById('matching-score');
        const scoreBarEl = document.getElementById('score-bar');
        const similarityScoreEl = document.getElementById('similarity-score');
        const preferenceScoreEl = document.getElementById('preference-score');
        const shapeScoreEl = document.getElementById('shape-score');
        const scoreBreakdownEl = document.getElementById('score-breakdown');

        const resultVisualMaleEl = document.getElementById('result-visual-male');
        const resultProfileTextMaleEl = document.getElementById('result-profile-text-male');
        const resultGroupNameMaleEl = document.getElementById('result-group-name-male');
        const resultGroupDescriptionMaleEl = document.getElementById('result-group-description-male');
        const maleTagsEl = document.getElementById('male-tags');

        const resultVisualFemaleEl = document.getElementById('result-visual-female');
        const resultProfileTextFemaleEl = document.getElementById('result-profile-text-female');
        const resultGroupNameFemaleEl = document.getElementById('result-group-name-female');
        const resultGroupDescriptionFemaleEl = document.getElementById('result-group-description-female');
        const femaleTagsEl = document.getElementById('female-tags');
        
        const relationshipAdviceEl = document.getElementById('relationship-advice');

        let maleRadarChart = null;
        let femaleRadarChart = null;
        let comparisonRadarChart = null;
        let totalExpectedAnswers = 0; // 답변해야 할 총 질문 수

        // --- 3. 핵심 유틸 함수 ---
        function findTagGroupKey(tag) {
            if (!tag) return null;
            for (const key in tagGroups) {
                if (tagGroups[key].tags.includes(tag)) { return key; }
            }
            return null;
        }

        function getRandomItem(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }
        
        // --- 4. 질문 렌더링 로직 ---
        
        /** 동적 질문 생성 함수 */
        function handleDynamic(radio, qId, gender, followupDataStr) {
            const followupData = JSON.parse(decodeURIComponent(followupDataStr));
            const followupContainerId = `${qId}-${gender}-followup`;
            const questionCard = radio.closest('.question-card');
            
            // 기존의 동적 질문 컨테이너 제거
            const existingFollowup = questionCard.querySelector('.dynamic-followup');
            if (existingFollowup) {
                existingFollowup.remove();
            }

            // 새 동적 질문 컨테이너 생성
            const followupContainer = document.createElement('div');
            followupContainer.id = followupContainerId;
            followupContainer.className = 'dynamic-followup';

            const optionsHTML = followupData.options.map((opt, index) => `
                <input type="radio" name="${qId}-followup-${gender}" value="${opt.value}" id="${qId}-followup-${gender}-${index}" class="hidden-radio">
                <label for="${qId}-followup-${gender}-${index}" class="option-label">
                    ${opt.text}
                </label>
            `).join('');

            followupContainer.innerHTML = `
                <p class="font-semibold mb-3 text-gray-800">${followupData.text}</p>
                <div class="space-y-2">${optionsHTML}</div>
            `;
            
            questionCard.appendChild(followupContainer);
        }

        /** 질문 유형 뱃지 HTML */
        function badgeHTML(type) {
            let text = '', color = '';
            if (type === 'similarity') { text = '유사성'; color = 'blue'; }
            else if (type === 'crossover') { text = '선호성 (교차)'; color = 'pink'; }
            else if (type === 'dynamic') { text = '선호성 (동적)'; color = 'amber'; }
            
            return `<span class="question-type-badge bg-${color}-100 text-${color}-800 border-${color}-300">${text}</span>`;
        }

        /** 질문 유형에 따라 HTML 생성 */
        function createQuestionHTML(q, gender) {
            let html = '';
            
            // 공통 옵션 생성기 (메인 질문용)
            const mainOptionsHTML = q.options.map((opt, index) => {
                let onChangeEvent = '';
                if (q.type === 'dynamic') {
                    // JSON 데이터를 문자열로 만들고 URI 인코딩하여 onchange 핸들러에 삽입
                    const followupDataStr = encodeURIComponent(JSON.stringify(opt.followup));
                    onChangeEvent = `onchange="handleDynamic(this, '${q.id}', '${gender}', '${followupDataStr}')"`;
                }
                return `
                    <input type="radio" name="${q.id}-me-${gender}" value="${opt.value}" data-tag="${opt.tag}" id="${q.id}-me-${gender}-${index}" class="hidden-radio" ${onChangeEvent}>
                    <label for="${q.id}-me-${gender}-${index}" class="option-label">
                        ${opt.text}
                    </label>
                `;
            }).join('');

            switch (q.type) {
                case 'similarity':
                    html = `<div class="question-card bg-white rounded-lg shadow-sm border">
                                ${badgeHTML(q.type)}
                                <p class="font-semibold mb-3 text-gray-800">${q.text}</p>
                                <div class="space-y-2">${mainOptionsHTML}</div>
                            </div>`;
                    break;
                case 'crossover':
                    const partnerOptionsHTML = q.options.map((opt, index) => `
                        <input type="radio" name="${q.id}-partner-${gender}" value="${opt.value}" id="${q.id}-partner-${gender}-${index}" class="hidden-radio">
                        <label for="${q.id}-partner-${gender}-${index}" class="option-label">
                            ${opt.text}
                        </label>
                    `).join('');
                    
                    html = `<div class="question-card bg-white rounded-lg shadow-sm border">
                                ${badgeHTML(q.type)}
                                <div class="space-y-4">
                                    <div>
                                        <p class="font-semibold mb-3 text-gray-800">${q.text_me}</p>
                                        <div class="space-y-2">${mainOptionsHTML}</div>
                                    </div>
                                    <hr class="my-4 border-dashed border-gray-300">
                                    <div>
                                        <p class="font-semibold mb-3 text-gray-800">${q.text_partner}</p>
                                        <div class="space-y-2">${partnerOptionsHTML}</div>
                                    </div>
                                </div>
                            </div>`;
                    break;
                case 'dynamic':
                    html = `<div class="question-card bg-white rounded-lg shadow-sm border">
                                ${badgeHTML(q.type)}
                                <p class="font-semibold mb-3 text-gray-800">${q.text}</p>
                                <div class="space-y-2">${mainOptionsHTML}</div>
                                <!-- 동적 질문은 여기에 삽입됨 -->
                            </div>`;
                    break;
            }
            return html;
        }

        /** 전체 질문 렌더링 */
        function renderQuestions() {
            let maleHTML = '', femaleHTML = '', lastMaleBrainType = '', lastFemaleBrainType = '';
            totalExpectedAnswers = 0; // 총 답변 수 초기화

            questions.forEach(q => {
                if (q.brainType !== lastMaleBrainType) {
                    maleHTML += `<h3 class="brain-type-header male-header">${q.brainType}</h3>`;
                    lastMaleBrainType = q.brainType;
                }
                maleHTML += createQuestionHTML(q, 'male');
                
                if (q.brainType !== lastFemaleBrainType) {
                    femaleHTML += `<h3 class="brain-type-header female-header">${q.brainType}</h3>`;
                    lastFemaleBrainType = q.brainType;
                }
                femaleHTML += createQuestionHTML(q, 'female');

                // 답변해야 할 총 라디오 그룹 수 계산 (남/여 각각)
                if (q.type === 'similarity') totalExpectedAnswers += 1;
                else if (q.type === 'crossover') totalExpectedAnswers += 2;
                else if (q.type === 'dynamic') totalExpectedAnswers += 2; // (메인 1 + 동적 1)
            });
            maleQuestionsContainer.innerHTML = maleHTML;
            femaleQuestionsContainer.innerHTML = femaleHTML;
        }

        /** '결' 설명 렌더링 */
        function renderGroupDescriptions() {
            let html = '';
            for (const key in sensoryProfiles) {
                const profile = sensoryProfiles[key];
                const tags = tagGroups[key].tags.join(', ');
                html += `<div class="p-2 bg-white rounded-md border">
                            <p><strong>${profile.name}:</strong> ${profile.description}</p>
                            <p class="mt-1 text-gray-500 text-xs">포함된 태그: ${tags}</p>
                         </div>`;
            }
            groupDescriptionsEl.innerHTML = html;
        }

        // --- 5. 차트 생성 함수 ---
        function generateProfile(groupKey) {
            const profileWords = sensoryWords[groupKey];
            const texture = getRandomItem(profileWords.texture);
            const color = getRandomItem(profileWords.color);
            const scent = getRandomItem(profileWords.scent);
            const shape = getRandomItem(profileWords.shape);
            return `${texture} ${color} ${scent}의 ${shape}`;
        }

        function createRadarChart(canvasId, label, data, color) {
            const ctx = document.getElementById(canvasId).getContext('2d');
             if (window[canvasId + 'ChartInstance']) { window[canvasId + 'ChartInstance'].destroy(); }
            const chartData = {
                labels: Object.values(sensoryProfiles).map(p => p.name.split(' ')[0]),
                datasets: [{
                    label: label,
                    data: Object.keys(sensoryProfiles).map(key => data[key] || 0),
                    backgroundColor: `rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.2)`,
                    borderColor: color,
                    pointBackgroundColor: color,
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: color
                }]
            };
            const options = {
                scales: { 
                    r: { 
                        angleLines: { display: true }, 
                        suggestedMin: 0, 
                        suggestedMax: Math.max(...Object.values(data), 5), // 최대값 보정
                        pointLabels: { fontSize: 14 } // 레이블 폰트 크기
                    } 
                },
                plugins: { legend: { position: 'bottom', } }
            };
             window[canvasId + 'ChartInstance'] = new Chart(ctx, { type: 'radar', data: chartData, options: options });
             return window[canvasId + 'ChartInstance'];
        }

        function createComparisonRadarChart(canvasId, maleData, femaleData) {
             const ctx = document.getElementById(canvasId).getContext('2d');
             if (window[canvasId + 'ChartInstance']) { window[canvasId + 'ChartInstance'].destroy(); }
             const chartData = {
                labels: Object.values(sensoryProfiles).map(p => p.name.split(' ')[0]),
                datasets: [
                    {
                        label: '남자',
                        data: Object.keys(sensoryProfiles).map(key => maleData[key] || 0),
                        backgroundColor: 'rgba(59, 130, 246, 0.2)', borderColor: '#3B82F6', pointBackgroundColor: '#3B82F6',
                        pointBorderColor: '#fff', pointHoverBackgroundColor: '#fff', pointHoverBorderColor: '#3B82F6'
                    },
                     {
                        label: '여자',
                        data: Object.keys(sensoryProfiles).map(key => femaleData[key] || 0),
                        backgroundColor: 'rgba(236, 72, 153, 0.2)', borderColor: '#EC4899', pointBackgroundColor: '#EC4899',
                        pointBorderColor: '#fff', pointHoverBackgroundColor: '#fff', pointHoverBorderColor: '#EC4899'
                    }
                ]
            };
            const options = {
                 scales: { 
                    r: { 
                        angleLines: { display: true }, 
                        suggestedMin: 0, 
                        suggestedMax: Math.max(...Object.values(maleData), ...Object.values(femaleData), 5), // 최대값 보정
                        pointLabels: { fontSize: 14 } // 레이블 폰트 크기
                    } 
                },
                 plugins: { legend: { position: 'bottom', } }
            };
            window[canvasId + 'ChartInstance'] = new Chart(ctx, { type: 'radar', data: chartData, options: options });
            return window[canvasId + 'ChartInstance'];
        }
        
        // --- 6. 결과 계산 로직 (100점 만점: 결 70 + 유사성 15 + 선호성 15) ---
        function calculateResults() {
            // 답변 완료 여부 확인
            const maleAnsweredCount = document.querySelectorAll('#male-questions input:checked').length;
            const femaleAnsweredCount = document.querySelectorAll('#female-questions input:checked');
            if (maleAnsweredCount < totalExpectedAnswers || femaleAnsweredCount.length < totalExpectedAnswers) {
                warningMessage.classList.remove('hidden');
                return;
            }
            warningMessage.classList.add('hidden');

            let rawSimilarityScore = 0;
            let maxRawSimilarityScore = 0;
            let rawPreferenceScore = 0;
            let maxRawPreferenceScore = 0;

            const maleTags = {}, femaleTags = {}, maleGroupCounts = {}, femaleGroupCounts = {};
            const maleMeNodes = {}, femaleMeNodes = {}; // '나의' 답변 노드 저장
            
            // 1. '나의' 답변 및 성향 집계 (모든 질문 루프)
            questions.forEach((q) => {
                const maleMeNode = document.querySelector(`input[name="${q.id}-me-male"]:checked`);
                const femaleMeNode = document.querySelector(`input[name="${q.id}-me-female"]:checked`);
                maleMeNodes[q.id] = maleMeNode; // 나중 비교를 위해 저장
                femaleMeNodes[q.id] = femaleMeNode; // 나중 비교를 위해 저장

                const maleMeTag = maleMeNode.dataset.tag;
                const femaleMeTag = femaleMeNode.dataset.tag;

                // '나의' 답변 태그 카운트 (성향 분석용)
                if (maleMeTag) {
                    maleTags[maleMeTag] = (maleTags[maleMeTag] || 0) + 1;
                    const maleGroupKey = findTagGroupKey(maleMeTag);
                    if(maleGroupKey) maleGroupCounts[maleGroupKey] = (maleGroupCounts[maleGroupKey] || 0) + 1;
                }
                if (femaleMeTag) {
                    femaleTags[femaleMeTag] = (femaleTags[femaleMeTag] || 0) + 1;
                    const femaleGroupKey = findTagGroupKey(femaleMeTag);
                    if(femaleGroupKey) femaleGroupCounts[femaleGroupKey] = (femaleGroupCounts[femaleGroupKey] || 0) + 1;
                }
            });

            // 2. '결' 모양 점수 계산 (최대 70점)
            const totalQuestionsCount = questions.length; // 18
            const maleGroupPercents = {}, femaleGroupPercents = {};
            let shapeSimilarity = 0; // 0 ~ 1 (0% ~ 100%)

            for (const key in sensoryProfiles) {
                const malePercent = (maleGroupCounts[key] || 0) / totalQuestionsCount;
                const femalePercent = (femaleGroupCounts[key] || 0) / totalQuestionsCount;
                maleGroupPercents[key] = malePercent;
                femaleGroupPercents[key] = femalePercent;
                // 두 분포에서 겹치는 영역 (낮은 값)을 합산
                shapeSimilarity += Math.min(malePercent, femalePercent);
            }
            // shapeSimilarity는 0~1 사이의 값 (예: 0.85 = 85% 유사)
            const finalShapeScore = shapeSimilarity * 70; // 70점 만점으로 환산

            
            // 3. '유사성'/'선호성' 점수 계산 (질문 루프)
            questions.forEach((q) => {
                const maleMeNode = maleMeNodes[q.id];
                const femaleMeNode = femaleMeNodes[q.id];
                const maleMeTag = maleMeNode.dataset.tag;
                const femaleMeTag = femaleMeNode.dataset.tag;
                const maleGroupKey = findTagGroupKey(maleMeTag);
                const femaleGroupKey = findTagGroupKey(femaleMeTag);

                // 질문 유형별 점수 계산
                switch (q.type) {
                    case 'similarity':
                        maxRawSimilarityScore += 6; // 유사성 배점 (일치 6점)
                        if (maleMeNode.value === femaleMeNode.value) {
                            rawSimilarityScore += 6; // 완전 일치
                        } else if (maleGroupKey && maleGroupKey === femaleGroupKey) {
                            rawSimilarityScore += 5; // 성향('결') 일치
                        }
                        break;
                    
                    case 'crossover':
                        maxRawPreferenceScore += 12; // 선호성 배점 (교차 12점) * 2 (양방향)
                        maxRawPreferenceScore += 12; 
                        
                        const malePartnerNode = document.querySelector(`input[name="${q.id}-partner-male"]:checked`);
                        const femalePartnerNode = document.querySelector(`input[name="${q.id}-partner-female"]:checked`);
                        const malePartnerTag = q.options.find(o => o.value === malePartnerNode.value)?.tag;
                        const femalePartnerTag = q.options.find(o => o.value === femalePartnerNode.value)?.tag;
                        const malePartnerGroup = findTagGroupKey(malePartnerTag);
                        const femalePartnerGroup = findTagGroupKey(femalePartnerTag);

                        // 남자가 원하는 파트너 모습 <-> 여자의 실제 모습
                        if (malePartnerNode.value === femaleMeNode.value) {
                            rawPreferenceScore += 12; // 완전 일치
                        } else if (malePartnerGroup && malePartnerGroup === femaleGroupKey) {
                            rawPreferenceScore += 8; // 성향('결') 일치
                        }
                        
                        // 여자가 원하는 파트너 모습 <-> 남자의 실제 모습
                        if (femalePartnerNode.value === maleMeNode.value) {
                            rawPreferenceScore += 12; // 완전 일치
                        } else if (femalePartnerGroup && femalePartnerGroup === maleGroupKey) {
                            rawPreferenceScore += 8; // 성향('결') 일치
                        }
                        break;
                    
                    case 'dynamic':
                        maxRawPreferenceScore += 10; // 선호성 배점 (동적 10점)
                        
                        const maleFollowupNode = document.querySelector(`input[name="${q.id}-followup-male"]:checked`);
                        const femaleFollowupNode = document.querySelector(`input[name="${q.id}-followup-female"]:checked`);
                        
                        // 'any'는 4로 간주
                        const maleDepth = parseInt(maleFollowupNode.value, 10); // 1, 2, 3, 4
                        const femaleDepth = parseInt(femaleFollowupNode.value, 10); // 1, 2, 3, 4
                        
                        const depthDiff = Math.abs(maleDepth - femaleDepth);
                        
                        // [남자의 선호 심도] vs [여자의 선호 심도] 비교
                        if (depthDiff === 0) {
                            rawPreferenceScore += 10; // 심도 완전 일치 (10점)
                        } else if (depthDiff === 1) {
                            rawPreferenceScore += 8; // 심도 1칸 차이 (8점)
                        } else if (depthDiff === 2) {
                            rawPreferenceScore += 6; // 심도 2칸 차이 (6점)
                        } else if (depthDiff === 3) {
                            rawPreferenceScore += 4; // 심도 3칸 차이 (4점)
                        }
                        break;
                }
            });

            // *** 만점 재계산 확인 ***
            // 유사성: 12개 * 6점 = 72점
            // 선호성 (교차): 3개 * 2 (양방향) * 12점 = 72점
            // 선호성 (동적): 3개 * 1 (심도비교) * 10점 = 30점
            // maxRawSimilarityScore = 72
            // maxRawPreferenceScore = 72 + 30 = 102
            
            // 4. 보너스 점수 환산 (15점 만점)
            const finalSimilarityScore = maxRawSimilarityScore > 0 ? (rawSimilarityScore / maxRawSimilarityScore) * 15 : 0;
            const finalPreferenceScore = maxRawPreferenceScore > 0 ? (rawPreferenceScore / maxRawPreferenceScore) * 15 : 0;

            // 5. 최종 총점 계산 (100점 만점)
            const finalTotal = finalShapeScore + finalSimilarityScore + finalPreferenceScore;

            // --- 7. 결과 표시 로직 ---

            // *** (수정) 100점 만점 환산 (표시용) ***
            const displayShapeScore = Math.round(shapeSimilarity * 100); // 0-1 -> 0-100
            const displaySimilarityScore = maxRawSimilarityScore > 0 ? Math.round((rawSimilarityScore / maxRawSimilarityScore) * 100) : 0;
            const displayPreferenceScore = maxRawPreferenceScore > 0 ? Math.round((rawPreferenceScore / maxRawPreferenceScore) * 100) : 0;
            
            // 점수 DOM 업데이트
            matchingScoreEl.textContent = `${Math.round(finalTotal)}점`; // 총점은 70+15+15
            scoreBarEl.style.width = `${Math.min(100, Math.round(finalTotal))}%`; 

            // (수정) 100점 만점 환산 점수로 표시
            shapeScoreEl.textContent = `${displayShapeScore}점`;
            similarityScoreEl.textContent = `${displaySimilarityScore}점`;
            preferenceScoreEl.textContent = `${displayPreferenceScore}점`;

            // 차트 영역 다시 그리기
            scoreBreakdownEl.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-3 gap-8 items-center">
                    <div class="text-center">
                        <h4 class="font-bold text-lg mb-2 text-blue-700">🤵‍♂️ 남자 '결' 분포</h4>
                        <canvas id="maleRadarChart"></canvas>
                    </div>
                    <div class="text-center">
                        <h4 class="font-bold text-lg mb-2 text-indigo-700">💖 두 분의 '결' 비교</h4>
                        <canvas id="comparisonRadarChart"></canvas>
                    </div>
                    <div class="text-center">
                         <h4 class="font-bold text-lg mb-2 text-pink-700">👰‍♀️ 여자 '결' 분포</h4>
                        <canvas id="femaleRadarChart"></canvas>
                    </div>
                </div>
            `;
            
            // 새 차트 생성
            maleRadarChart = createRadarChart('maleRadarChart', '남자', maleGroupCounts, '#3B82F6');
            femaleRadarChart = createRadarChart('femaleRadarChart', '여자', femaleGroupCounts, '#EC4899');
            comparisonRadarChart = createComparisonRadarChart('comparisonRadarChart', maleGroupCounts, femaleGroupCounts);

            // 프로필 생성
            const dominantMaleGroupKey = Object.keys(maleGroupCounts).length > 0 ? Object.keys(maleGroupCounts).reduce((a, b) => maleGroupCounts[a] > maleGroupCounts[b] ? a : b) : 'ADAPTIVE_BALANCED';
            const dominantFemaleGroupKey = Object.keys(femaleGroupCounts).length > 0 ? Object.keys(femaleGroupCounts).reduce((a, b) => femaleGroupCounts[a] > femaleGroupCounts[b] ? a : b) : 'ADAPTIVE_BALANCED';
            const maleProfileData = sensoryProfiles[dominantMaleGroupKey];
            const femaleProfileData = sensoryProfiles[dominantFemaleGroupKey];
            combinedGradientEl.style.background = `linear-gradient(to right, ${maleProfileData.colorCode}, ${femaleProfileData.colorCode})`;
            resultVisualMaleEl.className = `mt-4 p-6 rounded-lg transition-all duration-500 ${maleProfileData.background}`;
            resultProfileTextMaleEl.textContent = generateProfile(dominantMaleGroupKey);
            resultGroupNameMaleEl.textContent = `남자는 '${maleProfileData.name}'`;
            resultGroupDescriptionMaleEl.textContent = maleProfileData.description;
            maleTagsEl.innerHTML = Object.entries(maleTags).sort((a, b) => b[1] - a[1]).map(([tag, count]) => `<span class="result-tag font-medium py-1 px-3 rounded-full text-sm">${tag}${count > 1 ? ` x${count}` : ''}</span>`).join('');
            resultVisualFemaleEl.className = `mt-4 p-6 rounded-lg transition-all duration-500 ${femaleProfileData.background}`;
            resultProfileTextFemaleEl.textContent = generateProfile(dominantFemaleGroupKey);
            resultGroupNameFemaleEl.textContent = `여자는 '${femaleProfileData.name}'`;
            resultGroupDescriptionFemaleEl.textContent = femaleProfileData.description;
            femaleTagsEl.innerHTML = Object.entries(femaleTags).sort((a, b) => b[1] - a[1]).map(([tag, count]) => `<span class="result-tag font-medium py-1 px-3 rounded-full text-sm">${tag}${count > 1 ? ` x${count}` : ''}</span>`).join('');

            // 관계 조언 수정 (100점 만점 기준)
            if (finalTotal > 85) {
                relationshipAdviceEl.textContent = `총점 ${Math.round(finalTotal)}점! (최고!) '결' 모양 기본 점수(${Math.round(finalShapeScore)}점)가 매우 높고, 보너스 점수까지 훌륭합니다. 두 분은 핵심 성향이 매우 비슷하고 서로를 잘 이해하는 천생연분입니다!`;
            } else if (finalTotal > 65) {
                 relationshipAdviceEl.textContent = `좋은 점수(${Math.round(finalTotal)}점)입니다! 두 분의 '결' 모양 기본 점수(${Math.round(finalShapeScore)}점)가 높아 근본적으로 잘 맞는 성향입니다. '유사성'(${displaySimilarityScore}점)과 '선호성'(${displayPreferenceScore}점) 점수를 확인하며 서로를 더 알아가보세요.`;
            } else if (finalTotal > 45) {
                 relationshipAdviceEl.textContent = `괜찮은 점수(${Math.round(finalTotal)}점)입니다. '결' 모양 점수(${Math.round(finalShapeScore)}점)가 조금 낮더라도, '선호성' 점수(${displayPreferenceScore}점)가 높다면 서로의 다름을 존중하고 맞춰가고 있다는 의미입니다.`;
            } else {
                relationshipAdviceEl.textContent = `두 분은 서로 다른 '결'을 가졌습니다 (총점 ${Math.round(finalTotal)}점). 하지만 이것은 성장의 기회가 될 수 있습니다. 서로의 '결'을 존중하고 '선호성' 점수(${displayPreferenceScore}점)를 올리기 위해 노력해보세요!`;
            }

            if (dominantMaleGroupKey === dominantFemaleGroupKey) {
                 relationshipAdviceEl.textContent += ` (두 분은 '${maleProfileData.name}'(으)로 핵심 '결'이 동일하여 서로를 깊이 이해하는 관계입니다.)`;
            } else {
                 relationshipAdviceEl.textContent += ` (두 분은 각각 '${maleProfileData.name}', '${femaleProfileData.name}'(으)로 서로 다른 '결'을 가졌지만, 이 다름이 서로의 세계를 넓혀줄 수 있습니다.)`;
            }

            questionSection.classList.add('hidden');
            resultsContainer.classList.remove('hidden');
            document.querySelectorAll('#results .fade-in').forEach(el => el.style.opacity = 0);
            setTimeout(() => {
                 document.querySelectorAll('#results .fade-in').forEach(el => el.classList.add('is-visible'));
            }, 10);
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // --- 9. 이벤트 리스너 ---
        retryBtn.addEventListener('click', () => {
            if (maleRadarChart) maleRadarChart.destroy();
            if (femaleRadarChart) femaleRadarChart.destroy();
            if (comparisonRadarChart) comparisonRadarChart.destroy();
            resultsContainer.classList.add('hidden');
            questionSection.classList.remove('hidden');
            // 질문 다시 렌더링 (동적 질문 초기화를 위해)
            renderQuestions(); 
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        /** 랜덤 답변 버튼 리스너 */
        randomBtn.addEventListener('click', () => {
            ['male', 'female'].forEach(gender => {
                questions.forEach(q => {
                    // 1. '나의' 질문에 랜덤 답변
                    const meRadios = document.querySelectorAll(`input[name="${q.id}-me-${gender}"]`);
                    if (meRadios.length > 0) {
                        const randomMeRadio = meRadios[Math.floor(Math.random() * meRadios.length)];
                        randomMeRadio.checked = true;
                        // 동적 질문 트리거를 위해 'change' 이벤트 강제 발생
                        randomMeRadio.dispatchEvent(new Event('change', { bubbles: true }));
                    }

                    // 2. '파트너' 질문(Crossover)에 랜덤 답변
                    if (q.type === 'crossover') {
                        const partnerRadios = document.querySelectorAll(`input[name="${q.id}-partner-${gender}"]`);
                         if (partnerRadios.length > 0) {
                            partnerRadios[Math.floor(Math.random() * partnerRadios.length)].checked = true;
                        }
                    }
                });
            });

            // 3. '동적' 질문에 랜덤 답변 (이벤트 발생 후 잠시 기다렸다가 실행)
            setTimeout(() => {
                ['male', 'female'].forEach(gender => {
                    questions.forEach(q => {
                        if (q.type === 'dynamic') {
                            const followupRadios = document.querySelectorAll(`input[name="${q.id}-followup-${gender}"]`);
                            if (followupRadios.length > 0) {
                                followupRadios[Math.floor(Math.random() * followupRadios.length)].checked = true;
                            }
                        }
                    });
                });
            }, 100); // 동적 질문이 렌더링될 시간 확보
        });

        calculateBtn.addEventListener('click', calculateResults);

        // --- 10. 초기 실행 ---
        renderQuestions();
        renderGroupDescriptions(); // '결' 설명 렌더링 호출
    </script>
</body>
</html>
