<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>서로의 '결' 알아보기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* 기본 스타일 */
        body { font-family: 'Noto+Sans+KR', sans-serif; }
        .question-card { 
            transition: all 0.3s ease-in-out; 
            position: relative;
            padding-top: 2.5rem;
            padding-left: 1rem;
            padding-right: 1rem;
        }
        .question-card:hover { 
            transform: translateY(-5px); 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
        }
        
        /* 뱃지 스타일 */
        .question-type-badge {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            font-size: 0.75rem;
            font-weight: 700;
            padding: 0.25rem 0.6rem;
            border-radius: 9999px;
            text-transform: uppercase;
            border: 1px solid;
        }
        .badge-similarity { background-color: #e0e7ff; color: #3730a3; border-color: #a5b4fc; }
        .badge-crossover { background-color: #fce7f3; color: #be185d; border-color: #f9a8d4; }
        .badge-dynamic { background-color: #fef3c7; color: #b45309; border-color: #fcd34d; }

        /* 커스텀 라디오 버튼 스타일 */
        .hidden-radio { display: none; }
        .option-label {
            display: block;
            border: 1px solid #d1d5db;
            padding: 0.75rem;
            border-radius: 0.5rem;
            cursor: pointer;
            background-color: #ffffff;
            transition: all 0.2s ease-in-out;
        }
        .option-label:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
        }
        .hidden-radio:checked + .option-label {
            background-color: #e0e7ff;
            border-color: #4f46e5;
            font-weight: 500;
            color: #1e40af;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }

        /* 기타 스타일 */
        .dynamic-followup { background-color: #fdfbf5; border-top: 2px dashed #fcd34d; margin-top: 1rem; padding: 1rem; border-radius: 0.5rem;}
        .result-tag { background-color: #f0f0f0; color: #374151; }
        .brain-type-header { font-size: 1.125rem; font-weight: 700; margin-top: 1.5rem; margin-bottom: 0.5rem; padding-bottom: 0.5rem; }
        .male-header { border-bottom: 2px solid #93c5fd; color: #1e40af; }
        .female-header { border-bottom: 2px solid #f9a8d4; color: #9d174d; }
        details > summary { list-style: none; }
        details > summary::-webkit-details-marker { display: none; }
        .fade-in { animation: fadeIn 1s ease-in-out forwards; }
        .fade-in-delay-1 { animation-delay: 0.2s; }
        .fade-in-delay-2 { animation-delay: 0.4s; }
        .fade-in-delay-3 { animation-delay: 0.6s; }
        .fade-in-delay-4 { animation-delay: 0.8s; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* 타로 카드 스타일 수정 */
        .tarot-card-visual {
            min-height: 380px;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            border-radius: 0.75rem;
            box-shadow: 0 6px 10px -1px rgba(0, 0, 0, 0.15);
            text-align: center;
            padding: 1rem;
            background-size: contain; /* 이미지 전체 표시 */
            background-repeat: no-repeat;
            background-position: center top;
            color: white;
            position: relative;
            overflow: hidden;
            background-color: #2b2b2b; /* 빈 공간 배경색 */
        }
        .tarot-card-visual::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.0)); /* 텍스트 가독성용 하단 그라데이션 */
            pointer-events: none;
        }
        .tarot-content-overlay {
            position: relative;
            z-index: 10;
            width: 100%;
            padding-bottom: 10px;
        }
        .tarot-card-name {
            font-size: 1.25rem;
            font-weight: 700;
            color: white;
            margin-top: 0.5rem;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.9);
        }
        .tarot-card-emoji {
             font-size: 2rem; 
             margin-bottom: 0.2rem;
             text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="main-container" class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8 md:mb-12">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800">서로의 '결' 알아보기</h1>
            <p class="mt-2 text-gray-600">질문에 답하고 두 분의 고유한 '결'과 매칭률을 확인해보세요.</p>
        </header>

        <!-- 점수 계산 방식 안내 -->
        <div class="mb-8 max-w-4xl mx-auto bg-indigo-50 p-4 rounded-lg text-sm text-gray-700 border border-indigo-200">
            <details>
                <summary class="font-semibold text-center text-indigo-800 mb-2 cursor-pointer">💡 점수 계산 방식 안내 (100점 만점)</summary>
                <div class="mt-2 space-y-3">
                    <div>
                        <p class="font-semibold">💖 최종 매칭 점수 (총 100점 만점):</p>
                        <p>- '결' 모양 점수(기본 70점) + '유사성 점수'(보너스 15점) + '선호성 점수'(보너스 15점)를 합산합니다.</p>
                    </div>
                    <div>
                        <p class="font-semibold">✨ '결' 모양 점수 (총점 중 70점):</p>
                        <p>- 두 분의 '결' 성향 분포(방사형 그래프)가 얼마나 비슷한지(0~100%) 계산하여, <strong>최대 70점</strong>의 기본 점수를 획득합니다.</p>
                    </div>
                    <div>
                        <p class="font-semibold">🤝 '유사성' 점수 (총점 중 15점):</p>
                        <p>- '유사성' 질문(10개)을 통해 획득한 원점수를 <strong>100점 만점</strong>으로 환산하여 보여드리고, 총점에는 <strong>최대 15점</strong> 비중으로 반영됩니다.</p>
                    </div>
                    <div>
                        <p class="font-semibold">🎯 '선호성' 점수 (총점 중 15점):</p>
                        <p>- '선호성' 질문(8개)을 통해 획득한 원점수를 <strong>100점 만점</strong>으로 환산하여 보여드리고, 총점에는 <strong>최대 15점</strong> 비중으로 반영됩니다.</p>
                    </div>
                    <!-- '결' 상세 설명 -->
                    <div id="group-descriptions" class="space-y-3 text-xs mt-4 pt-4 border-t border-indigo-200">
                        <p class="font-semibold text-sm text-indigo-800">※ 6가지 성향 그룹 (결)</p>
                        <!-- Descriptions will be injected here by JS -->
                    </div>
                </div>
            </details>
        </div>
        
        <!-- '결' 모양 점수 계산 상세 -->
        <div class="mb-8 max-w-4xl mx-auto bg-green-50 p-4 rounded-lg text-sm text-gray-700 border border-green-200">
            <details>
                <summary class="font-semibold text-center text-green-800 mb-2 cursor-pointer">📈 '결' 모양 점수 (70점) 계산 상세 (클릭)</summary>
                <div class="mt-2 space-y-3">
                    <p>'결' 모양 점수는 <strong>총점의 70%</strong>를 차지하는 가장 중요한 기본 점수입니다.</p>
                    <ol class="list-decimal list-inside space-y-2">
                        <li><strong>'결'별 답변 집계:</strong> 두 분의 답변을 6가지 '결'로 분류하여 분포를 만듭니다.</li>
                        <li><strong>유사도 계산:</strong> 두 사람의 방사형 그래프가 얼마나 겹치는지(유사도 0~100%) 계산합니다.</li>
                        <li><strong>점수 환산:</strong> 유사도(%)에 최대 배점인 70점을 곱하여 최종 점수를 산출합니다.</li>
                    </ol>
                </div>
            </details>
        </div>
        
        <!-- 보너스 점수 계산 상세 -->
        <div class="mb-8 max-w-4xl mx-auto bg-yellow-50 p-4 rounded-lg text-sm text-gray-700 border border-yellow-200" id="bonus-score-details">
            <details>
                <summary class="font-semibold text-center text-yellow-800 mb-2 cursor-pointer">📊 보너스 점수 (30점) 계산 상세 (클릭)</summary>
                <div class="mt-2 space-y-3">
                    <p>보너스 점수는 두 분의 일치도(유사성)와 맞춤도(선호성)를 평가합니다. 각 항목은 100점 만점으로 표시되지만, 총점에는 15점씩 반영됩니다.</p>
                    <div class="pt-2">
                        <p class="font-semibold">🤝 '유사성' (최대 15점 반영)</p>
                        <ul class="list-disc list-inside text-xs text-gray-600 pl-2">
                            <li>완전 일치: 4점 / 성향 일치: 3점</li>
                        </ul>
                    </div>
                    <div class="pt-2">
                        <p class="font-semibold">🎯 '선호성' (최대 15점 반영)</p>
                        <ul class="list-disc list-inside text-xs text-gray-600 pl-2">
                            <li>교차 질문: 완전 일치 8점 / 성향 일치 4점</li>
                            <li>동적 질문: 심도에 따라 6점 ~ 4점 차등 지급</li>
                        </ul>
                    </div>
                </div>
            </details>
        </div>

        <div id="question-section">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div class="bg-blue-50 p-6 rounded-xl shadow-lg">
                    <h2 class="text-2xl font-bold text-center mb-6 text-blue-800">🤵‍♂️ 남자</h2>
                    <div id="male-questions" class="space-y-6"></div>
                </div>
                <div class="bg-pink-50 p-6 rounded-xl shadow-lg">
                    <h2 class="text-2xl font-bold text-center mb-6 text-pink-800">👰‍♀️ 여자</h2>
                    <div id="female-questions" class="space-y-6"></div>
                </div>
            </div>
            <div class="text-center mt-8">
                <div id="warning-message" class="mb-4 text-center text-red-500 font-semibold hidden">
                    모든 질문에 답변해주세요! (동적 질문 포함)
                </div>
                <button id="random-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-full text-lg transition-transform transform hover:scale-105 shadow-lg mr-4">
                    랜덤으로 답변하기
                </button>
                <button id="calculate-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-8 rounded-full text-lg transition-transform transform hover:scale-105 shadow-lg">
                    결과 확인하기
                </button>
            </div>
        </div>

        <div id="results" class="hidden mt-8 md:mt-12 bg-white p-8 rounded-2xl shadow-2xl text-center">
            <h2 class="text-3xl md:text-4xl font-bold text-gray-800 opacity-0 fade-in">최종 결과</h2>
            
            <!-- 1. 메인 스코어 섹션 -->
            <div class="my-8 opacity-0 fade-in fade-in-delay-1">
                <p class="text-xl text-gray-600 font-medium">두 분의 가치관 매칭 점수는...</p>
                <p id="matching-score" class="text-7xl font-extrabold text-indigo-700 my-4">0점</p>
                <p class="text-sm text-gray-500 font-bold">(100점 만점)</p>

                <!-- 메인 점수 3분할 카드 -->
                <div class="flex flex-col sm:flex-row justify-center gap-4 mt-8 max-w-3xl mx-auto">
                    <!-- 유사성 -->
                    <div class="flex-1 text-center p-4 rounded-lg border border-blue-200 shadow-md" style="background-color: #f0f8ff;">
                        <p class="font-semibold text-gray-700 text-base">🤝 유사성 점수</p>
                        <p id="similarity-score-main" class="text-3xl font-extrabold text-blue-600 my-1">0점</p>
                        <p class="text-xs text-gray-500">(100점 만점 환산)</p>
                    </div>
                    <!-- 선호성 -->
                    <div class="flex-1 text-center p-4 rounded-lg border border-pink-200 shadow-md" style="background-color: #fff0f5;">
                        <p class="font-semibold text-gray-700 text-base">🎯 선호성 점수</p>
                        <p id="preference-score-main" class="text-3xl font-extrabold text-pink-600 my-1">0점</p>
                        <p class="text-xs text-gray-500">(100점 만점 환산)</p>
                    </div>
                    <!-- 결 모양 -->
                    <div class="flex-1 text-center p-4 rounded-lg border border-green-200 shadow-md" style="background-color: #f0fff4;">
                        <p class="font-semibold text-gray-700 text-base">✨ '결' 모양 점수</p>
                        <p id="shape-score-main" class="text-3xl font-extrabold text-green-600 my-1">0점</p>
                        <p class="text-xs text-gray-500">(100점 만점 환산)</p>
                    </div>
                </div>

                <!-- 점수 바 -->
                <div class="w-full bg-gray-200 rounded-full h-4 max-w-lg mx-auto mt-8">
                    <div id="score-bar" class="bg-indigo-500 h-4 rounded-full transition-all duration-1000 ease-out" style="width: 0%"></div>
                </div>
            </div>

            <!-- 2. 상세 점수 분석 (새로운 6분할 섹션) -->
            <div class="mt-8 pt-6 border-t opacity-0 fade-in fade-in-delay-2">
                <h3 class="text-2xl font-bold text-gray-800 mb-4">🏆 상세 항목별 평가</h3>
                
                <div class="max-w-4xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-6 text-left">
                    
                    <!-- 유사성 상세 분석 -->
                    <div class="bg-blue-50 p-4 rounded-xl shadow-inner border border-blue-200">
                        <h4 class="font-bold text-lg text-blue-700 mb-3">🤝 유사성 세부 항목 (총 100점 만점)</h4>
                        <div id="similarity-breakdown" class="space-y-2">
                            <!-- S1: 행동 유사성 -->
                        </div>
                    </div>

                    <!-- 선호성 상세 분석 -->
                    <div class="bg-pink-50 p-4 rounded-xl shadow-inner border border-pink-200">
                        <h4 class="font-bold text-lg text-pink-700 mb-3">🎯 선호성 세부 항목 (총 100점 만점)</h4>
                        <div id="preference-breakdown" class="space-y-2">
                            <!-- P1: 교차-관계 선호 -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- 3. '결'별 상세 분석 (레이더 차트) -->
            <div class="mt-8 pt-6 border-t opacity-0 fade-in fade-in-delay-3">
                <h3 class="text-2xl font-bold text-gray-800 mb-4">📈 '결'별 상세 분포</h3>
                <p class="text-gray-600 text-sm mb-4">(※ '나의 모습'으로 답한 성향의 분포입니다)</p>
                <div id="score-breakdown" class="max-w-3xl mx-auto text-left space-y-4">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-8 items-center">
                        <div class="text-center">
                            <h4 class="font-bold text-lg mb-2 text-blue-700">🤵‍♂️ 남자 '결' 분포</h4>
                            <canvas id="maleRadarChart"></canvas>
                        </div>
                        <div class="text-center">
                            <h4 class="font-bold text-lg mb-2 text-indigo-700">💖 두 분의 '결' 비교</h4>
                            <canvas id="comparisonRadarChart"></canvas>
                        </div>
                        <div class="text-center">
                             <h4 class="font-bold text-lg mb-2 text-pink-700">👰‍♀️ 여자 '결' 분포</h4>
                            <canvas id="femaleRadarChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 4. 타로 궁합 섹션 -->
            <div class="mt-8 pt-6 border-t opacity-0 fade-in fade-in-delay-4">
                <h3 class="text-2xl font-bold text-gray-800 mb-6">🔮 타로로 보는 우리의 '결' 궁합</h3>
                <div id="tarot-reading-section">
                    <div id="tarot-loading" class="text-center text-gray-500 p-8 hidden">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-500 mx-auto mb-3"></div>
                        <p>두 분의 '결'을 타로로 해석하는 중입니다...</p>
                    </div>
                    <div id="tarot-content">
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8 items-start">
                            <div id="male-tarot-card-container" class="bg-blue-50 p-4 rounded-xl shadow-md border border-blue-200"></div>
                            <div class="flex flex-col items-center justify-center text-5xl text-indigo-500 mt-6 md:mt-0">
                                <span class="opacity-75">↔️</span>
                                <span class="text-sm text-gray-500 mt-2">두 분의 결</span>
                            </div>
                            <div id="female-tarot-card-container" class="bg-pink-50 p-4 rounded-xl shadow-md border border-pink-200"></div>
                        </div>
                        <div class="mt-8 bg-gray-100 p-6 rounded-xl text-left shadow-lg">
                            <h4 class="text-xl font-bold text-indigo-700 mb-3">🔗 궁합 해석</h4>
                            <p id="tarot-compatibility-text" class="text-gray-700 leading-relaxed whitespace-pre-wrap"></p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="mt-8 pt-6 border-t opacity-0 fade-in fade-in-delay-4">
                <h3 class="text-2xl font-bold text-gray-800 mb-4">✨ 우리의 종합 '결'</h3>
                <div id="combined-gradient" class="w-full h-32 md:h-40 rounded-2xl flex items-center justify-center relative overflow-hidden shadow-inner">
                     <p id="gradient-text" class="text-white text-3xl font-bold" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">Our Vibe</p>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mt-8 opacity-0 fade-in fade-in-delay-4">
                <!-- 남자 결과 -->
                <div class="bg-white p-6 rounded-xl shadow-lg border">
                    <p class="text-gray-600 font-semibold">🤵‍♂️ 남자의 '결'은...</p>
                    <div id="result-visual-male" class="mt-4 p-6 rounded-lg transition-all duration-500">
                        <h3 id="result-profile-text-male" class="text-2xl font-extrabold text-white" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.4);"></h3>
                    </div>
                    <div class="mt-4 text-left">
                        <p id="result-group-name-male" class="font-bold text-lg text-gray-800"></p>
                        <p id="result-group-description-male" class="text-gray-600 mt-1 text-sm"></p>
                    </div>
                </div>
                <!-- 여자 결과 -->
                <div class="bg-white p-6 rounded-xl shadow-lg border">
                    <p class="text-gray-600 font-semibold">👰‍♀️ 여자의 '결'은...</p>
                    <div id="result-visual-female" class="mt-4 p-6 rounded-lg transition-all duration-500">
                        <h3 id="result-profile-text-female" class="text-2xl font-extrabold text-white" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.4);"></h3>
                    </div>
                    <div class="mt-4 text-left">
                        <p id="result-group-name-female" class="font-bold text-lg text-gray-800"></p>
                        <p id="result-group-description-female" class="text-gray-600 mt-1 text-sm"></p>
                    </div>
                </div>
            </div>

            <div class="mt-8 pt-6 border-t opacity-0 fade-in fade-in-delay-4">
                <h3 class="text-xl font-bold text-gray-800 mb-4">💌 최종 두 분 관계 조언</h3>
                <p id="relationship-advice" class="text-gray-700 bg-gray-100 p-4 rounded-lg"></p>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8 pt-6 border-t opacity-0 fade-in fade-in-delay-4">
                 <div>
                    <h3 class="text-lg font-bold text-gray-800 mb-4">남자의 상세 성향 태그</h3>
                    <div id="male-tags" class="flex flex-wrap gap-2 justify-center"></div>
                </div>
                <div>
                    <h3 class="text-lg font-bold text-gray-800 mb-4">여자의 상세 성향 태그</h3>
                    <div id="female-tags" class="flex flex-wrap gap-2 justify-center"></div>
                </div>
            </div>

            <div class="mt-12 opacity-0 fade-in fade-in-delay-4">
                 <button id="retry-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-3 px-8 rounded-full text-lg">
                    다시하기
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. 데이터 구조 정의 --- (이전과 동일)
        const questions = [
            // ... (이전 코드와 동일한 질문 목록)
            // --- 1) Action (나의 행동 유형) - 유사성 3문제 ---
            {
                id: 'q1', type: 'similarity', brainType: 'Action (나의 행동 유형)',
                text: '인스타그램 스토리에 사진을 올린다면 어떤 사진을 선택하시겠어요?',
                options: [
                     { value: '1', text: '아름다운 자연경관에서 찍은 내 사진 (경험중시형)', tag: '#경험중시형'},
                     { value: '2', text: '미슐랭 5스타 고급 레스토랑의 음식 사진 (성취지향형)', tag: '#성취지향형'},
                     { value: '3', text: '친구들과 함께 파티를 즐기는 역동적인 사진 (사교형)', tag: '#사교형'},
                     { value: '4', text: '인스타그램 스토리는 잘 올리지 않는 편 (안정지향형)', tag: '#안정지향형'}
                 ]
            },
            {
                id: 'q2', type: 'similarity', brainType: 'Action (나의 행동 유형)',
                text: '선호하는 운동 스타일은 무엇인가요?',
                options: [
                     { value: '1', text: '혼자 집중하며 즐기는 운동 (러닝, 헬스 등) (자기계발형)', tag: '#자기계발형'},
                     { value: '2', text: '파트너나 팀과 함께하는 운동 (테니스, 축구 등) (활동적인)', tag: '#활동적인'},
                     { value: '3', text: '운동은 별로 즐기지 않음 (정적인)', tag: '#정적인'}
                 ]
            },
            {
                id: 'q22', type: 'similarity', brainType: 'Action (나의 행동 유형)',
                text: '당신의 이상적인 주말은 어떤 모습에 가까운가요?',
                options: [
                     { value: '1', text: '집에서 편안하게 휴식을 취하며 재충전 (집순이/집돌이)', tag: '#집순이/집돌이'},
                     { value: '2', text: '새로운 것을 배우거나 취미 활동에 몰두 (자기계발형)', tag: '#자기계발형'},
                     { value: '3', text: '친구들을 만나거나 새로운 사람들과 어울림 (사교형)', tag: '#사교형'},
                     { value: '4', text: '가까운 곳으로 여행을 떠나 새로운 경험 (모험추구형)', tag: '#모험추구형'}
                 ]
            },
            
            // --- 2) Emotion (나의 감정 및 관계 유형) - 유사성 4문제, 선호성 교차 2문제 ---
            {
                id: 'q4', type: 'crossover', brainType: 'Emotion (나의 감정 및 관계 유형)',
                text_me: '꿈꾸는 프러포즈는 어떤 모습인가요?',
                text_partner: '파트너에게 어떤 프러포즈를 해주고 싶으신가요?',
                options: [
                     { value: '1', text: '분위기 좋은 레스토랑에서의 로맨틱한 프러포즈 (낭만주의형)', tag: '#낭만주의형'},
                     { value: '2', text: '많은 사람들 앞에서의 깜짝 프러포즈 (이벤트선호)', tag: '#이벤트선호'},
                     { value: '3', text: '둘만의 추억이 담긴 장소에서의 진솔한 프러포즈 (관계중심형)', tag: '#관계중심형'},
                     { value: '4', text: '화려함보다 진심이 담긴 반지와 편지 (실용주의형)', tag: '#실용주의형'}
                 ]
            },
            {
                id: 'q5', type: 'crossover', brainType: 'Emotion (나의 감정 및 관계 유형)',
                text_me: '연인이 했을 때 가장 설레는 행동은 무엇인가요?',
                text_partner: '연인을 설레게 하기 위해 어떤 행동을 하고 싶나요?',
                options: [
                     { value: '1', text: '내가 했던 말을 기억하고 세심하게 챙겨줄 때 (세심함중시)', tag: '#세심함중시'},
                     { value: '2', text: '힘든 하루 끝에 말없이 꼭 안아줄 때 (스킨십중시)', tag: '#스킨십중시'},
                     { value: '3', text: '나의 일이나 성과를 진심으로 응원하고 지지해줄 때 (정서적지지)', tag: '#정서적지지'},
                     { value: '4', text: '함께 시간을 보낼 때 나에게 온전히 집중해줄 때 (시간공유형)', tag: '#시간공유형'}
                 ]
            },
            {
                id: 'q23', type: 'similarity', brainType: 'Emotion (나의 감정 및 관계 유형)',
                text: '공공장소에서의 애정표현(스킨십)에 대해 어떻게 생각하시나요?',
                options: [
                     { value: '1', text: '손 잡는 것 정도는 괜찮지만, 그 이상은 조심스러움 (보수적가치관)', tag: '#보수적가치관'},
                     { value: '2', text: '주변에 피해만 주지 않는다면 자유롭게 표현 가능 (자유로운표현)', tag: '#자유로운표현'},
                     { value: '3', text: '애정표현은 둘만 있는 사적인 공간에서 하는 것이 좋음 (사생활중시)', tag: '#사생활중시'},
                     { value: '4', text: '장소와 분위기에 따라 유연하게 달라질 수 있음 (상황적응형)', tag: '#상황적응형'}
                 ]
            },
            {
                id: 'q26', type: 'similarity', brainType: 'Emotion (나의 감정 및 관계 유형)',
                text: '비 오는 날, 퇴근 시간에 맞춰 연인이 회사 앞에 우산을 들고 나타났습니다. 당신의 반응은?',
                options: [
                     { value: '1', text: '우와, 어떻게 알고 왔어? 와줘서 정말 고마워! (감정표현형)', tag: '#감정표현형'},
                     { value: '2', text: '괜찮은데 왜 고생스럽게 왔어~ 걱정되잖아 (배려형)', tag: '#배려형'},
                     { value: '3', text: '마침 보고 싶었는데, 이렇게 깜짝으로 보니 더 좋다! (낭만주의형)', tag: '#낭만주의형'},
                     { value: '4', text: '잘 왔다! 이왕 만났으니 맛있는 거 먹으러 갈까? (실용주의형)', tag: '#실용주의형'}
                 ]
            },
            {
                id: 'q17', type: 'similarity', brainType: 'Emotion (나의 감정 및 관계 유형)',
                text: '내 연인이 내 친구의 깻잎을 떼주는 것을 보았습니다. 당신의 생각은?',
                options: [
                     { value: '1', text: '아무렇지 않음. 그럴 수 있음 (쿨한연애)', tag: '#쿨한연애'},
                     { value: '2', text: '기분은 좀 그렇지만 티 내지 않음 (감정조절형)', tag: '#감정조절형'},
                     { value: '3', text: '연인에게 장난스럽게 서운함을 표현함 (관계중심형)', tag: '#관계중심형'},
                     { value: '4V', text: '절대 안됨. 그 자리에서 이야기함 (원칙주의형)', tag: '#원칙주의형'}
                 ]
            },
            {
                id: 'q18', type: 'similarity', brainType: 'Emotion (나의 감정 및 관계 유형)',
                text: '선호하는 반려동물이 있나요?',
                options: [
                     { value: '1', text: '활동적이고 애교 많은 강아지가 좋음 (활동적인)', tag: '#활동적인'},
                     { value: '2', text: '독립적이고 차분한 고양이가 좋음 (차분한)', tag: '#차분한'},
                     { value: '3', text: '둘 다 좋지만, 키울 자신은 없음 (현실주의형)', tag: '#현실주의형'},
                     { value: '4', text: '반려동물을 키우는 것은 선호하지 않음 (개인주의형)', tag: '#개인주의형'}
                 ]
            },

            // --- 3) Thinking (나의 가치관 및 생각 유형) - 유사성 3문제, 선호성 교차 3문제, 선호성 동적 3문제 ---
             {
                id: 'q11', type: 'similarity', brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text: '성공한 친구가 확실한 투자처라며 주식 정보를 주었습니다. 어떻게 하시겠어요?',
                options: [
                     { value: '1', text: '친구를 믿고 \'영끌\' 대출을 해서 투자 (과감한투자)', tag: '#과감한투자'},
                     { value: '2', text: '현재 보유한 현금 전부를 투자 (공격적투자)', tag: '#공격적투자'},
                     { value: '3', text: '여유 자금의 절반 정도만 신중하게 투자 (안정적투자)', tag: '#안정적투자'},
                     { value: '4V', text: '스스로 분석 없이는 투자하지 않음 (원칙주의형)', tag: '#원칙주의형'}
                 ]
            },
            {
                id: 'q19', type: 'crossover', brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text_me: '연인과 갈등이 생겼을 때, 당신은 어떻게 해결하나요?',
                text_partner: '연인과 갈등이 생겼을 때, 파트너가 어떻게 해결해주길 바라나요?',
                options: [
                     { value: '1', text: '감정이 가라앉을 때까지 기다렸다가 차분히 대화 (논리적대화)', tag: '#논리적대화'},
                     { value: '2', text: '갈등이 길어지는게 싫어 빨리 사과하고 넘어감 (갈등회피형)', tag: '#갈등회피형'},
                     { value: '3', text: '감정을 솔직하게 모두 표현해야 직성이 풀림 (감정표현형)', tag: '#감정표정형'},
                     { value: '4', text: '함께 문제를 분석하고 해결책을 찾으려 노력함 (문제해결형)', tag: '#문제해결형'}
                 ]
            },
            {
                id: 'q27', type: 'dynamic', brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text: '배우자가 청소기를 돌렸는데 구석에 먼지가 그대로 있습니다. 당신의 반응은?',
                options: [
                    { 
                        value: '1', text: '우와, 청소해줬네! 정말 고마워~ (긍정적강화)', tag: '#긍정적강화',
                        followup: {
                            text: '만약 계속 이런 일이 반복된다면, 당신이 바라는 파트너의 모습은?',
                            options: [
                                { value: '1', text: '먼저 미안하다고 말하며 고쳐주길 바람 (심도 1)' },
                                { value: '2', text: '말을 안해도 다음엔 잘 해주길 바람 (심도 2)' },
                                { value: '3', text: '괜찮아, 내가 하면 돼! (심도 3)' }
                            ]
                        }
                    },
                    { 
                        value: '2', text: '고마워! 다음엔 이쪽 구석도 한번 더 신경 써주면 완벽할 것 같아! (피드백제공)', tag: '#피드백제공',
                        followup: {
                            text: '만약 피드백을 줬는데도 고쳐지지 않는다면?',
                            options: [
                                { value: '1', text: '왜 고쳐지지 않는지 솔직하게 대화함 (심도 1)' },
                                { value: '2', text: '기분 나쁘지 않게 다시 한번 말함 (심도 2)' },
                                { value: '3', text: '그냥 내가 하고 맘 (심도 3)' }
                            ]
                        }
                    },
                    { 
                        value: '3', text: '말없이 내가 직접 나머지 먼지를 청소함 (갈등회피형)', tag: '#갈등회피형',
                        followup: {
                            text: '계속 말없이 청소하다 보면 언젠가 불만이 생길 것 같습니다. 파트너가 어떻게 해주길 바라나요?',
                            options: [
                                { value: '1', text: '내가 말하기 전에 먼저 알아차리고 미안해하길 바람 (심도 1)' },
                                { value: '2', text: '눈치껏 다음부턴 잘 해주길 바람 (심도 2)' },
                                { value: '3', text: '괜찮아, 내가 더 깔끔하니까 내가 할게 (심도 3)' }
                            ]
                        }
                    },
                    { 
                        value: '4', text: '그 정도는 괜찮음. 신경 쓰지 않음 (YOLO)', tag: '#YOLO',
                        followup: {
                            text: '신경쓰지 않는 당신! 그래도 파트너가 최소한 이정도는 해줬으면 하는게 있나요?',
                            options: [
                                { value: '1', text: '내가 신경 안쓰는 만큼, 다른걸 잘 챙겨주길 (심도 1)' },
                                { value: '2', text: '그래도 눈에 보이는 큰 것만 치워주길 (심도 2)' },
                                { value: '3', text: '같이 YOLO! 청소는 업체에 맡기자 (심도 3)' }
                            ]
                        }
                    }
                ]
            },
            {
                id: 'q24', type: 'crossover', brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text_me: '결혼 후 양가 부모님 댁 방문 빈도는 어느 정도가 적당하다고 생각하시나요?',
                text_partner: '파트너가 어느 정도의 빈도로 방문하길 원할 것 같나요?',
                options: [
                     { value: '1', text: '명절이나 생신 등 특별한 날에만 방문 (독립성중시)', tag: '#독립성중시'},
                     { value: '2', text: '한두 달에 한 번 정도는 정기적으로 방문 (가족중심형)', tag: '#가족중심형'},
                     { value: '3', text: '정해진 것 없이, 필요하거나 원할 때 자유롭게 왕래 (자유추구형)', tag: '#자유추구형'},
                     { value: '4', text: '가까이 살면서 자주 왕래하며 가깝게 지냄 (관계중심형)', tag: '#관계중심형'}
                 ]
            },
            {
                id: 'q25', type: 'dynamic', brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text: '가사(집안일) 분담에 대한 당신의 생각은?',
                options: [
                    { 
                        value: '1', text: '각자 잘하는 일을 정해서 명확하게 역할을 나눔 (효율중시형)', tag: '#효율중시형',
                        followup: {
                            text: '만약 정해진 역할분담이 잘 지켜지지 않는다면?',
                            options: [
                                { value: '1', text: '즉시 규칙을 다시 정하자고 말함 (심도 1)' },
                                { value: '2', text: '일단 내가 하면서 다시 지켜보자고 함 (심도 2)' },
                                { value: '3', text: '그냥 내가 하고 맘 (심도 3)' }
                            ]
                        }
                    },
                    { 
                        value: '2', text: '정해놓지 않고, 시간이 되거나 먼저 보는 사람이 함 (자율형)', tag: '#자율형',
                        followup: {
                            text: '만약 나만 계속 집안일을 하게 된다면?',
                            options: [
                                { value: '1', text: '눈치껏 상대방도 하길 바람 (심도 1)' }, // 순서 변경
                                { value: '2', text: '기분이 나쁨, 결국 역할을 정하자고 말함 (심도 2)' }, // 순서 변경
                                { value: '3', text: '상관없음, 내가 더 깔끔하니 내가 함 (심도 3)' }
                            ]
                        }
                    },
                    { 
                        value: '3', text: '주말 등 특정 시간을 정해 함께 집중적으로 처리 (계획형)', tag: '#계획형',
                        followup: {
                            text: '만약 파트너가 주말 약속을 이유로 자꾸 빠진다면?',
                            options: [
                                { value: '1', text: '주말 약속을 이해하지만, 청소는 꼭 같이 하자고 설득 (심도 1)' },
                                { value: '2', text: '이번주는 봐주지만, 다음주는 꼭 같이 하자고 함 (심도 2)' },
                                { value: '3', text: '친구 만나는게 중요하지, 청소는 내가 함 (심도 3)' }
                            ]
                        }
                    },
                    { 
                        value: '4', text: '가사도우미, 식기세척기 등 시스템을 적극 활용 (편리성추구)', tag: '#편리성추구',
                        followup: {
                            text: '시스템 활용에 비용이 많이 든다면?',
                            options: [
                                { value: '1', text: '비용이 들어도 나의 편의가 더 중요함 (심도 1)' },
                                { value: '2', text: '비용을 줄이고 우리가 좀 더 하자고 함 (심도 2)' },
                                { value: '3', text: '시스템을 포기하고 우리가 다 함 (심도 3)' }
                            ]
                        }
                    }
                ]
            },
            {
                id: 'q12', type: 'similarity', brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text: '이상적인 자녀 수는 몇 명인가요?',
                options: [
                     { value: '1', text: '딩크(DINK)족, 자녀 없이 둘만의 삶 (개인주의형)', tag: '#개인주의형'},
                     { value: '2', text: '한 명의 자녀에게 집중 (계획형)', tag: '#계획형'},
                     { value: '3', text: '안정적이고 화목한 두 명의 자녀 (가정중심형)', tag: '#가정중심형'},
                     { value: '4', text: '다둥이 가정을 꿈꿈 (다자녀선호)', tag: '#다자녀선호'}
                 ]
            },
            {
                id: 'q13', type: 'crossover', brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text_me: '선호하는 부부의 경제 활동 형태는 무엇인가요?',
                text_partner: '파트너가 어떤 경제 활동 형태를 선호하길 바라나요?',
                options: [
                     { value: '1', text: '각자의 커리어를 존중하는 맞벌이 (성장지향형)', tag: '#성장지향형'},
                     { value: '2', text: '상황에 따라 유연하게, 가능하면 맞벌이 (상황적응형)', tag: '#상황적응형'},
                     { value: '3', text: '한 사람은 경제활동, 한 사람은 가정을 돌보는 외벌이 (전통적가치관)', tag: '#전통적가치관'},
                     { value: '4', text: '경제적 여유만 있다면, 자유롭게 살고 싶음 (자유추구형)', tag: '#자유추구형'}
                 ]
            },
            {
                id: 'q15', type: 'similarity', brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text: '당신이 결혼을 원하는 가장 큰 이유는 무엇인가요?',
                options: [
                     { value: '1', text: '정서적 안정감과 평생의 동반자를 얻기 위해 (안정지향형)', tag: '#안정지향형'},
                     { value: '2', text: '사랑하는 사람과 가정을 꾸리기 위해 (가정중심형)', tag: '#가정중심형'},
                     { value: '3', text: '더 나은 미래를 함께 계획하고 성장하기 위해 (성장지향형)', tag: '#성장지향형'},
                     { value: '4', text: '함께 다양한 경험을 하며 인생을 더 즐겁게 살기 위해 (모험추구형)', tag: '#모험추구형'}
                 ]
            },
            {
                id: 'q16', type: 'dynamic', brainType: 'Thinking (나의 가치관 및 생각 유형)',
                text: '신혼집을 구한다면, 당신의 우선순위는 어디에 있나요?',
                options: [
                    { 
                        value: '1', text: '미래 가치를 보고 서울 중심지 아파트 선택 (미래가치중시)', tag: '#미래가치중시',
                        followup: {
                            text: '미래 가치를 위해 현재의 불편함(예: 좁은 평수)을 감수해야 한다면?',
                            options: [
                                { value: '1', text: '미래를 위해 얼마든지 감수 가능 (심도 1)' },
                                { value: '2', text: '조금 고민되지만 감수할 의향 있음 (심도 2)' },
                                { value: '3', text: '현재의 행복이 더 중요함 (심도 3)' }
                            ]
                        }
                    },
                    { 
                        value: '2', text: '현재의 안정을 위해 경기도 신축 아파트 선택 (현재안정중시)', tag: '#현재안정중시',
                        followup: {
                            text: '현재의 안정을 위해 미래 가치(시세차익)를 포기해야 한다면?',
                            options: [
                                { value: '1', text: '현재가 중요하므로 기꺼이 포기 (심도 1)' },
                                { value: '2', text: '아쉽지만 안정에 만족 (심도 2)' },
                                { value: '3', text: '미래 가치도 포기할 수 없음 (심도 3)' }
                            ]
                        }
                    },
                    { 
                        value: '3', text: '직주근접이 가장 중요함 (실용주의형)', tag: '#실용주의형',
                        followup: {
                            text: '직주근접을 위해 집 컨디션(예: 구축, 좁은 평수)을 포기해야 한다면?',
                            options: [
                                { value: '1', text: '출퇴근 시간이 아까움, 무조건 감수 (심도 1)' },
                                { value: '2', text: '고민되지만 감수 (심도 2)' },
                                { value: '3', text: '집이 편해야 함, 포기 불가 (심도 3)' }
                            ]
                        }
                    },
                    { 
                        value: '4', text: '개인의 취향이 담긴 인테리어의 집을 원함 (심미주의형)', tag: '#심미주의형',
                        followup: {
                            text: '인테리어를 위해 위치나 평수를 포기해야 한다면?',
                            options: [
                                { value: '1', text: '나의 만족이 중요함, 감수 가능 (심도 1)' },
                                { value: '2', text: '적당히 타협 (심도 2)' },
                                { value: '3', text: '현실적인게 더 중요함, 포기 (심도 3)' }
                            ]
                        }
                    }
                ]
            }
        ];
        
        const tagGroups = {
            EMOTIONAL_CONNECT: { tags: ['#낭만주의형', '#관계중심형', '#세심함중시', '#스킨십중시', '#정서적지지', '#배려형', '#감정표현형', '#긍정적강화', '#가족중심형', '#다자녀선호', '#시간공유형'] },
            PRACTICAL_RATIONAL: { tags: ['#실용주의형', '#원칙주의형', '#현실주의형', '#논리적대화', '#문제해결형', '#효율중시형', '#피드백제공', '#미래가치중시', '#현재안정중시'] }, 
            STABILITY_ORIENTED: { tags: ['#안정지향형', '#안정적투자', '#계획형', '#집순이/집돌이', '#보수적가치관', '#전통적가치관', '#정적인'] },
            ACTIVE_EXPERIENCE: { tags: ['#경험중시형', '#성취지향형', '#사교형', '#활동적인', '#모험추구형', '#이벤트선호', '#과감한투자', '#공격적투자', '#자기계발형', '#성장지향형'] },
            AUTONOMY_FLEXIBILITY: { tags: ['#개인주의형', '#쿨한연애', '#자유로운표현', '#사생활중시', '#자유추구형', '#독립성중시', '#자율형', '#갈등회피형', '#자유로운', '#YOLO'] }, 
            ADAPTIVE_BALANCED: { tags: ['#상황적응형', '#감정조절형', '#편리성추구', '#심미주의형', '#차분한'] }
        };
        const sensoryProfiles = {
            EMOTIONAL_CONNECT: { name: "감성의 결", description: "사람들과의 따뜻한 유대와 감정적 교류에서 행복을 느끼는 사람입니다. 타인의 마음에 깊이 공감하며, 관계를 통해 안정감을 얻는 섬세한 '결'을 가졌습니다.", background: "bg-pink-400", colorCode: "#F9A8D4" },
            PRACTICAL_RATIONAL: { name: "이성의 결", description: "명확한 논리와 효율성을 중요하게 생각하며, 문제 해결에 뛰어난 능력을 보입니다. 감정보다 이성적인 판단을 우선시하는 시원하고 투명한 '결'을 가졌습니다.", background: "bg-blue-500", colorCode: "#3B82F6" },
            STABILITY_ORIENTED: { name: "안정의 결", description: "예측 가능하고 편안한 환경에서 가장 큰 안정감을 느낍니다. 꾸준함과 신뢰를 바탕으로 삶을 단단하게 가꾸어 나가는 차분하고 깊은 '결'을 가졌습니다.", background: "bg-green-500", colorCode: "#22C55E" },
            ACTIVE_EXPERIENCE: { name: "활동의 결", description: "새로운 도전과 경험을 통해 삶의 에너지를 얻는 열정적인 사람입니다. 끊임없이 성장하고 세상을 탐험하고자 하는 반짝이는 '결'을 가졌습니다.", background: "bg-amber-500", colorCode: "#F59E0B" },
            AUTONOMY_FLEXIBILITY: { name: "자유의 결", description: "자신만의 고유한 개성과 자유를 무엇보다 중요하게 생각합니다. 정해진 틀에 얽매이지 않고, 자신만의 속도와 방식으로 세상을 살아가는 신비로운 '결'을 가졌습니다.", background: "bg-purple-500", colorCode: "#8B5CF6" },
            ADAPTIVE_BALANCED: { name: "조화의 결", description: "어떤 상황에서도 유연하게 대처하며, 갈등보다는 조화를 추구합니다. 치우치지 않는 균형감각으로 주변과 자연스럽게 어우러지는 맑고 깨끗한 '결'을 가졌습니다.", background: "bg-gray-500", colorCode: "#6B7280" }
        };
        const sensoryWords = {
            EMOTIONAL_CONNECT: { texture: ["따뜻한", "부드러운", "포근한"], color: ["핑크빛", "복숭아빛"], scent: ["꽃향기", "달콤한 과일향"], shape: ["솜사탕", "실크 스카프", "구름"] },
            PRACTICAL_RATIONAL: { texture: ["시원한", "매끄러운", "단단한"], color: ["하늘색", "회색빛"], scent: ["비 냄새", "민트향"], shape: ["수정", "유리구슬", "얼음 조각"] },
            STABILITY_ORIENTED: { texture: ["단단한", "차분한", "편안한"], color: ["연두색", "갈색빛"], scent: ["나무향", "젖은 흙냄새"], shape: ["조약돌", "나뭇잎", "이끼"] },
            ACTIVE_EXPERIENCE: { texture: ["뜨거운", "톡톡 튀는", "짜릿한"], color: ["노란색", "주황색"], scent: ["상큼한 레몬향", "타오르는 장작 냄새"], shape: ["별", "불꽃", "보석 원석"] },
            AUTONOMY_FLEXIBILITY: { texture: ["신비로운", "오묘한", "가벼운"], color: ["보랏빛", "남색"], scent: ["깊은 밤공기 냄새", "고요한 숲의 향"], shape: ["안개", "자수정", "깃털"] },
            ADAPTIVE_BALANCED: { texture: ["깨끗한", "맑은", "투명한"], color: ["흰색", "투명한"], scent: ["무향(無香)", "맑은 공기 냄새"], shape: ["물방울", "이슬", "백자"] }
        };

        // --- 타로 카드 매핑 (이미지 URL 업데이트) ---
        const tarotMap = {
            EMOTIONAL_CONNECT: { name: "연인 (The Lovers)", meaning: "관계와 조화", emoji: "💕", img: "https://upload.wikimedia.org/wikipedia/ko/d/db/RWS_Tarot_06_Lovers.jpg" },
            PRACTICAL_RATIONAL: { name: "정의 (Justice)", meaning: "균형과 논리", emoji: "⚖️", img: "https://upload.wikimedia.org/wikipedia/ko/e/e0/RWS_Tarot_11_Justice.jpg" },
            STABILITY_ORIENTED: { name: "교황 (The Hierophant)", meaning: "전통과 안정", emoji: "✝️", img: "https://upload.wikimedia.org/wikipedia/ko/8/8d/RWS_Tarot_05_Hierophant.jpg" },
            ACTIVE_EXPERIENCE: { name: "전차 (The Chariot)", meaning: "진취와 추진", emoji: "🏆", img: "https://upload.wikimedia.org/wikipedia/ko/9/9b/RWS_Tarot_07_Chariot.jpg" },
            AUTONOMY_FLEXIBILITY: { name: "광대 (The Fool)", meaning: "자유와 모험", emoji: "🃏", img: "https://upload.wikimedia.org/wikipedia/ko/9/90/RWS_Tarot_00_Fool.jpg" },
            ADAPTIVE_BALANCED: { name: "절제 (Temperance)", meaning: "조화와 평온", emoji: "🍶", img: "https://upload.wikimedia.org/wikipedia/ko/f/f8/RWS_Tarot_14_Temperance.jpg" }
        };

        // --- 타로 궁합 해석 데이터베이스 (조합 다양화) ---
        // 키: MaleGyeol_FemaleGyeol 순서
        const tarotReadings = {
            // 1. 동질 조합 (6가지)
            EMOTIONAL_CONNECT_EMOTIONAL_CONNECT: [
                "두 분은 '연인' 카드처럼 깊은 감정적 유대감을 자랑합니다. 서로의 마음을 누구보다 잘 이해하며, 따뜻하고 안정적인 관계를 이어갈 수 있습니다. 다만, 때때로 지나친 감정 몰입으로 인해 현실적인 문제 해결이 늦어질 수 있으니, 감정적인 지지와 함께 현실적인 조언도 나누는 균형이 필요합니다.",
                "두 분은 '연인' 카드에 나타난 것처럼 사랑과 조화가 넘치는 이상적인 커플입니다. 서로의 감정적 필요를 즉각적으로 채워주지만, 중요한 결정을 내릴 때는 감정보다는 이성적인 대화를 시도해 보는 것이 관계의 지속성에 큰 도움이 됩니다.",
            ],
            PRACTICAL_RATIONAL_PRACTICAL_RATIONAL: [
                "두 분은 '정의' 카드처럼 논리와 공정함을 중시합니다. 투명한 관계와 명확한 규칙을 선호하여 오해가 적지만, 때로는 차가운 이성이 관계의 열정을 식힐 수 있습니다. 규칙에서 벗어난 작은 이벤트와 따뜻한 감정 표현을 통해 유연성을 더하세요.",
                "'정의' 카드가 두 분의 관계를 상징합니다. 이는 서로의 의견을 존중하고 합리적인 기준을 따르는 관계임을 의미합니다. 완벽함을 추구하다가 서로에게 지나치게 비판적이 될 수 있으니, 가끔은 완벽하지 않은 상대방의 모습까지 사랑으로 감싸는 포용력이 필요합니다.",
            ],
            STABILITY_ORIENTED_STABILITY_ORIENTED: [
                "두 분은 '교황' 카드처럼 전통과 안정을 추구합니다. 함께 쌓아온 신뢰와 예측 가능한 일상이 관계의 가장 큰 힘입니다. 새로운 경험이나 변화를 두려워하지 말고, 가끔은 예상치 못한 즐거운 일탈을 시도해 관계에 활력을 불어넣으세요.",
                "'교황'이 상징하는 것처럼, 두 분은 견고한 믿음 위에 관계를 세웠습니다. 서로의 가치관이 같아 충돌이 적지만, 너무 고정된 패턴에 갇히지 않도록 주의해야 합니다. 새로운 취미를 함께 찾거나 모험적인 여행을 떠나보는 것을 추천합니다.",
            ],
            ACTIVE_EXPERIENCE_ACTIVE_EXPERIENCE: [
                "두 분 모두 '전차' 카드처럼 추진력과 열정이 넘칩니다. 목표를 향해 함께 나아가며 큰 성과를 이룰 수 있는 역동적인 커플입니다. 다만, 두 사람 모두 주도권을 가지려 할 때 충돌이 발생할 수 있으니, 번갈아 가며 리더 역할을 수행하는 지혜가 필요합니다.",
                "'전차'의 에너지가 두 분의 관계를 이끌고 있습니다. 함께하는 모든 일이 빠르게 진행되며 지루할 틈이 없습니다. 서로의 속도가 너무 빨라 상대방의 작은 신호를 놓칠 수 있습니다. 가끔은 잠시 멈춰서 서로에게 집중하는 시간을 가지세요.",
            ],
            AUTONOMY_FLEXIBILITY_AUTONOMY_FLEXIBILITY: [
                "두 분은 '광대' 카드처럼 자유를 사랑하고 틀에 얽매이지 않습니다. 서로의 독립성을 존중하는 관계이지만, 때로는 관계의 책임이나 미래 계획에 소홀해질 수 있습니다. 즐거운 현재만큼이나 함께 설계하는 미래에 대해서도 진지하게 이야기 나누는 시간이 필요합니다.",
                "'광대'가 두 장 겹쳤습니다. 이 관계는 무한한 자유와 가능성을 의미합니다. 너무 자유로워 보여 남들이 걱정할 수 있으니, 둘만의 명확한 '우리 관계의 규칙'을 세우는 것이 오히려 이 자유를 더욱 단단하게 만들 수 있습니다.",
            ],
            ADAPTIVE_BALANCED_ADAPTIVE_BALANCED: [
                "두 분은 '절제' 카드처럼 조화와 균형이 뛰어납니다. 갈등 상황에서도 감정을 절제하고 평화롭게 해결하려는 성향이 강합니다. 너무 과도한 조화 추구는 오히려 본심을 숨기게 만들 수 있으니, 때로는 솔직하게 감정을 드러내는 용기가 필요합니다.",
                "'절제' 카드는 두 분의 관계가 이미 완벽한 조화를 이루고 있음을 보여줍니다. 서로에게 기대하지 않는 만큼 실망도 적지만, 관계를 더욱 깊게 만들기 위해 서로의 내면 깊숙한 곳까지 탐험하려는 적극적인 노력을 기울여보세요.",
            ],
            // 2. 이종 조합 (15가지 - 중복 회피를 위해 A_B 형태로만 정의)
            PRACTICAL_RATIONAL_EMOTIONAL_CONNECT: [ // 이성 + 감성
                "남자의 '정의'와 여자의 '연인' 카드는 이성과 감성이 만난 조합입니다. 남자의 논리가 여자의 감수성을 안정적으로 지지해주지만, 여자는 남자의 딱딱함에 상처받기 쉽습니다. 남자는 이성적인 분석 대신 따뜻한 포옹을, 여자는 감정적인 표현 대신 명확한 요구를 전달할 때 관계가 발전합니다.",
                "남자는 '정의' 카드처럼 명확하고, 여자는 '연인' 카드처럼 따뜻합니다. 남자의 합리적인 계획이 관계의 기반을 다지고, 여자의 사랑이 그 기반을 채웁니다. 서로에게 부족한 부분을 배우고 채워주는 '이상적인 보완 관계'입니다. 다만, 서로의 영역을 침범하지 않도록 경계를 존중해야 합니다.",
            ],
            PRACTICAL_RATIONAL_STABILITY_ORIENTED: [ // 이성 + 안정
                 "남자의 '정의'와 여자의 '교황' 카드는 규칙과 전통의 만남입니다. 두 분 모두 예측 가능하고 신뢰를 바탕으로 한 관계를 선호하여 안정감이 높습니다. 하지만 새로운 시도에 망설임이 많아 정체될 수 있습니다. 한 분이라도 새로운 도전을 제안하고 나머지 한 분이 신중하게 검토하여 실행하는 방식으로 균형을 맞추세요.",
                 "이성과 안정이 만나 견고한 성을 쌓았습니다. 두 분에게 금전적인 문제나 갈등은 거의 없을 것입니다. 다만, 너무 완벽한 관계를 만들려고 애쓰다가 서로에게 부담을 줄 수 있습니다. '쉬어가는 날'을 정해 아무 규칙 없이 즐기는 시간을 가지는 것이 좋습니다.",
            ],
            PRACTICAL_RATIONAL_ACTIVE_EXPERIENCE: [ // 이성 + 활동
                "남자의 '정의'와 여자의 '전차' 카드는 계획과 실행력의 완벽한 조화입니다. 남자의 이성적인 분석이 여자의 추진력을 낭비 없이 목표로 이끌어줍니다. 충돌 시 남자는 감정을 배제한 논리로 상처를 줄 수 있고, 여자는 남자의 조언을 잔소리로 받아들일 수 있습니다. 서로의 역할을 인정하고 존중해야 합니다.",
                "'전차'의 빠른 속도에 '정의'가 제동을 걸어줍니다. 함께하는 모든 일에서 효율과 성과를 낼 수 있는 비즈니스 파트너 같은 궁합입니다. 가끔은 목표 달성 외의 '소소한 행복'에 집중하는 낭만적인 시간을 의도적으로 만들어보세요.",
            ],
            PRACTICAL_RATIONAL_AUTONOMY_FLEXIBILITY: [ // 이성 + 자유
                 "남자의 '정의'와 여자의 '광대' 카드는 가장 예측 불가능하면서도 흥미로운 조합입니다. 남자는 여자의 자유로움을 이해하기 어렵지만 매력을 느끼고, 여자는 남자의 단단함에 안정감을 느낍니다. 남자는 융통성을, 여자는 관계에 대한 책임감을 조금씩 키워나가야 합니다. 너무 다른 부분은 통제하려 하지 말고 '있는 그대로' 존중하는 것이 핵심입니다.",
                 "이성적인 규칙과 자유로운 모험심의 충돌 가능성이 있습니다. 남자는 '정의'처럼 파트너에게 명확한 기한을 요구하는 대신, 넓은 시야를 가지세요. 여자는 '광대'처럼 약속을 가볍게 여기지 말고, 중요한 일에 대한 책임은 다하겠다는 신뢰를 보여줘야 합니다.",
            ],
            PRACTICAL_RATIONAL_ADAPTIVE_BALANCED: [ // 이성 + 조화
                 "남자의 '정의'와 여자의 '절제' 카드는 안정적인 관계를 만드는 최고의 조합 중 하나입니다. 남자는 합리적으로 문제를 해결하고, 여자는 그 결정을 조화롭게 수용합니다. 하지만 두 분 모두 너무 갈등을 피하려 하거나 자기 주장을 굽히는 경향이 있어, 중요한 문제가 곪아갈 수 있습니다. 건강한 의견 충돌을 두려워하지 마세요.",
                 "이 관계는 매우 평화롭고 원만합니다. '절제'의 포용력과 '정의'의 명확함이 만나 어떤 어려움도 잘 헤쳐나갈 수 있습니다. 다만, 관계의 모든 에너지가 '이성적 해결'에만 집중될 수 있으니, 함께 감성적인 취미(미술, 음악 등)를 공유하는 것이 좋습니다.",
            ],
            EMOTIONAL_CONNECT_STABILITY_ORIENTED: [ // 감성 + 안정
                 "남자의 '연인'과 여자의 '교황' 카드는 따뜻한 마음과 신뢰가 만난 조합입니다. 남자의 감정적인 교류 능력과 여자의 안정적인 가치관이 만나 이상적인 가정을 꾸릴 수 있습니다. 남자는 감정 기복이 심한 모습을 자제하고, 여자는 감정을 솔직하게 표현하는 연습이 필요합니다. 서로에게 '정서적인 고향'이 되어줄 수 있습니다.",
                 "이 관계는 '연인'의 헌신과 '교황'의 믿음으로 매우 깊은 신뢰 관계를 형성합니다. 하지만 외부의 변화에 취약할 수 있으니, 둘만의 세계에 갇히지 말고 주변 사람들과의 관계를 활발하게 유지하는 것이 관계를 더욱 단단하게 만듭니다.",
            ],
            EMOTIONAL_CONNECT_ACTIVE_EXPERIENCE: [ // 감성 + 활동
                 "남자의 '연인'과 여자의 '전차' 카드는 애정과 추진력의 조합입니다. 남자의 다정함이 여자의 강인함을 부드럽게 만들고, 여자의 목표 지향성이 남자의 삶에 방향을 제시합니다. 여자는 때때로 남자에게 '관계 중심'의 시간을 요구하고, 남자는 여자의 목표 달성을 진심으로 응원할 때 시너지가 극대화됩니다.",
                 "이 관계는 열정과 낭만이 공존합니다. '전차'의 에너지가 관계를 지루하지 않게 끌어가고, '연인'의 감성이 그 여정을 의미로 채웁니다. 충돌 시에는 감정적인 대화와 함께 빠른 화해를 추구하는 것이 중요합니다.",
            ],
            EMOTIONAL_CONNECT_AUTONOMY_FLEXIBILITY: [ // 감성 + 자유
                 "남자의 '연인'과 여자의 '광대' 카드는 사랑과 자유라는 상반된 가치가 만났습니다. 남자는 관계에 헌신적이고, 여자는 독립적이어서 남자가 서운함을 느끼기 쉽습니다. 남자는 집착 대신 '믿음'이라는 선물을, 여자는 자유로운 활동 속에서도 '나는 너와 연결되어 있다'는 신호를 끊임없이 보내야 합니다.",
                 "'광대'의 예측 불가능한 행동도 '연인'의 깊은 사랑으로 이해할 수 있습니다. 이 관계는 서로의 다름을 사랑할 때 가장 행복하며, 한쪽의 헌신적인 사랑이 다른 한쪽의 자유를 구속하지 않도록 섬세한 관심이 필요합니다.",
            ],
            EMOTIONAL_CONNECT_ADAPTIVE_BALANCED: [ // 감성 + 조화
                 "남자의 '연인'과 여자의 '절제' 카드는 완벽한 정서적 조화를 이룹니다. 남자는 감정을 자유롭게 표현하고, 여자는 그것을 부드럽게 받아주고 균형을 잡아줍니다. 다만, 여자의 '절제'는 때로 '본심 숨기기'를 의미할 수 있습니다. 남자는 파트너의 미묘한 감정 변화를 놓치지 않고 솔직한 대화를 유도해야 합니다.",
                 "이 관계는 매우 평온하고 안정적입니다. '절제'의 포용력과 '연인'의 사랑이 엮여 갈등을 최소화합니다. 두 분이 함께 만든 세상이 외부의 영향을 받지 않도록, 주기적으로 외부와 소통하는 노력이 필요합니다.",
            ],
            STABILITY_ORIENTED_ACTIVE_EXPERIENCE: [ // 안정 + 활동 (위에서 정의함, 역순)
                 "남자의 '교황'과 여자의 '전차' 카드는 안정과 활동이 역동적으로 섞인 조합입니다. 여자의 넘치는 에너지가 남자의 삶을 풍요롭게 만들지만, 남자의 느리고 신중한 태도가 여자의 답답함을 유발할 수 있습니다. 남자는 변화를 두려워하지 말고 함께 뛰어들 준비를, 여자는 때로는 남자의 템포에 맞춰 쉬어가는 '숨 고르기'를 할 때 관계가 건강해집니다.",
            ],
            STABILITY_ORIENTED_AUTONOMY_FLEXIBILITY: [ // 안정 + 자유
                 "남자의 '교황'과 여자의 '광대' 카드는 규칙과 자유라는 극단적인 성향의 만남입니다. 남자는 파트너의 예측 불가능성에 불안함을 느끼고, 여자는 남자의 틀 안에 갇히는 것을 답답해합니다. 남자는 파트너의 '광대'적인 면을 '매력'으로 인정하고, 여자는 중요한 약속만큼은 '교황'처럼 신중하게 지켜야 합니다.",
                 "이 관계는 서로에게 가장 필요한 것을 제공합니다. 남자는 안정적인 기반을, 여자는 활력을 불어넣습니다. 남자는 큰 틀에서 파트너에게 자유를 허용하고, 여자는 그 자유를 남자의 신뢰를 깨지 않는 선에서 누릴 때 행복해집니다.",
            ],
            STABILITY_ORIENTED_ADAPTIVE_BALANCED: [ // 안정 + 조화
                 "남자의 '교황'과 여자의 '절제' 카드는 매우 안정적이고 조화로운 관계를 구축합니다. 두 분 모두 갈등을 싫어하고 평화를 추구합니다. 관계의 가장 큰 위험은 '지루함'입니다. '절제'의 유연함과 '교황'의 믿음을 바탕으로 예상치 못한 새로운 경험들을 관계에 주입하세요.",
                 "이 조합은 오랜 시간 변함없는 사랑을 지킬 수 있습니다. 여자의 '절제'가 남자의 '교황'적인 보수성을 잘 녹여내어 유연하게 만듭니다. 두 분 모두 너무 수동적으로 관계에 머무르지 말고, 각자의 개성을 존중하며 적극적으로 상대방의 필요를 채워주세요.",
            ],
            ACTIVE_EXPERIENCE_AUTONOMY_FLEXIBILITY: [ // 활동 + 자유
                 "남자의 '전차'와 여자의 '광대' 카드는 에너지 넘치는 모험가 커플입니다. 두 분 모두 새로운 것을 추구하며, 정적인 것을 싫어합니다. 함께라면 세상 어디든 갈 수 있지만, 둘만의 안정적인 '집'이라는 개념이 희미해질 수 있습니다. 현실적인 기반을 잊지 않도록 한 분은 '현실적인 체크 리스트'를 담당해야 합니다.",
                 "이 관계는 자유와 추진력이 만나 폭발적인 시너지를 냅니다. '전차'는 목적 없이 움직이는 '광대'에게 방향을 제시하고, '광대'는 '전차'에게 예상치 못한 기쁨을 줍니다. 함께 여행이나 새로운 도전을 할 때 가장 궁합이 좋습니다.",
            ],
            ACTIVE_EXPERIENCE_ADAPTIVE_BALANCED: [ // 활동 + 조화
                 "남자의 '전차'와 여자의 '절제' 카드는 강력한 추진력과 유연한 수용력이 만났습니다. 남자의 목표 달성 욕구를 여자의 '절제'가 안정적으로 서포트해 줍니다. 남자는 파트너의 의견을 경청하고, 여자는 남자의 속도를 방해하지 않는 '최적의 타이밍'에 자신의 의견을 개진할 때 관계의 효율이 최고로 발휘됩니다.",
                 "이 관계는 '절제'의 평화로운 조언이 '전차'의 무리한 질주를 막아줍니다. 여자는 남자의 행동을 있는 그대로 믿고, 남자는 여자의 균형감각을 존중할 때 영원히 함께 나아갈 수 있는 최고의 파트너가 될 것입니다.",
            ],
            AUTONOMY_FLEXIBILITY_ADAPTIVE_BALANCED: [ // 자유 + 조화 (위에서 정의함, 역순)
                 "남자의 '광대'와 여자의 '절제' 카드는 자유와 조화의 만남입니다. 남자의 예측 불가능한 매력이 여자의 삶에 재미를 더하지만, 여자의 지나친 조화 추구가 남자의 자유를 속박할 수 있습니다. 남자는 충동적인 행동 전 파트너에게 한 마디 상의를, 여자는 파트너의 '광대'적인 면모를 있는 그대로 인정하고 즐기는 태도를 가질 때 행복해집니다.",
            ],
            // 3. 예외 조합에 대한 정의 (역순 조합)
            EMOTIONAL_CONNECT_PRACTICAL_RATIONAL: [
                 "남자의 '연인'과 여자의 '정의' 카드는 감성과 이성이 만난 조합입니다. 남자의 부드러움이 여자의 냉철함을 녹일 수 있지만, 여자의 분석적인 태도가 남자의 감정을 상하게 할 수 있습니다. 여자는 감정을 존중하는 대화법을 연습하고, 남자는 여자의 계획을 믿고 따라주는 신뢰를 보여줄 때 최고의 궁합을 자랑합니다.",
            ],
            STABILITY_ORIENTED_PRACTICAL_RATIONAL: [
                 "남자의 '교황'과 여자의 '정의' 카드는 전통과 논리의 만남입니다. 두 분 모두 원칙을 중시하여 관계의 갈등 요인이 적습니다. 남자의 보수적인 틀이 여자의 합리적인 결정을 방해할 수 있습니다. 남자는 유연성을 배우고, 여자는 남자의 방식에 대한 '신뢰'를 보낼 때 관계가 조화롭습니다.",
            ],
            ACTIVE_EXPERIENCE_PRACTICAL_RATIONAL: [
                 "남자의 '전차'와 여자의 '정의' 카드는 실행과 판단의 조합입니다. 남자의 빠른 실행력과 여자의 합리적인 판단이 만나 최고의 효율을 냅니다. 남자는 여자의 조언을 '지적'이 아닌 '애정 어린 분석'으로 받아들이고, 여자는 남자의 열정을 존중하는 표현을 자주 사용해야 관계가 더욱 따뜻해집니다.",
            ],
            AUTONOMY_FLEXIBILITY_PRACTICAL_RATIONAL: [
                 "남자의 '광대'와 여자의 '정의' 카드는 자유와 이성적인 규칙의 만남입니다. 남자의 자유분방함이 여자의 규칙적인 삶에 새로운 영감을 주지만, 여자의 통제 욕구가 남자의 자유를 속박할 수 있습니다. 여자는 파트너의 '광대'적인 면모를 너그럽게 포용하고, 남자는 중요한 결정 시 파트너에게 '함께 상의하는 모습'을 보여줄 때 안정적인 관계가 됩니다.",
            ],
            ADAPTIVE_BALANCED_PRACTICAL_RATIONAL: [
                 "남자의 '절제'와 여자의 '정의' 카드는 조화와 논리의 만남입니다. 남자의 유연함이 여자의 날카로움을 중화시키고, 여자의 합리성이 남자의 모호함을 해소합니다. 남자는 자신의 감정을 솔직히 표현해야 하고, 여자는 남자의 조화 추구를 약함으로 보지 않는 존중이 필요합니다.",
            ],
            // 나머지 역순 조합은 이미 상기 조합에 포함되어 있거나 DEFAULT_READING으로 처리됩니다.
            DEFAULT_READING: [
                "두 분의 성향은 매우 독특하게 결합되어 있습니다. 이 관계는 정해진 공식이 없는 새로운 여정입니다. 서로의 '결'에 대한 깊은 존중과 소통만이 이 관계를 특별하고 견고하게 만드는 열쇠입니다. 상대방의 가장 낯선 부분에서 새로운 매력을 발견할 수 있습니다.",
                "두 분의 카드 조합은 예측 불가능한 흥미진진한 관계를 나타냅니다. 다름 속에서 시너지를 찾고, 상대방의 성향을 '배우고 싶은 것'으로 바라보는 긍정적인 태도가 중요합니다. 충돌을 피하기보다는, 충돌이 생길 때마다 대화로 풀어가며 관계를 업그레이드하세요.",
            ]
        };


        // --- 2. DOM 요소 정의 (이전 코드와 동일) ---
        const maleQuestionsContainer = document.getElementById('male-questions');
        const femaleQuestionsContainer = document.getElementById('female-questions');
        const calculateBtn = document.getElementById('calculate-btn');
        const randomBtn = document.getElementById('random-btn');
        const resultsContainer = document.getElementById('results');
        const warningMessage = document.getElementById('warning-message');
        const questionSection = document.getElementById('question-section');
        const retryBtn = document.getElementById('retry-btn');
        const combinedGradientEl = document.getElementById('combined-gradient');
        const groupDescriptionsEl = document.getElementById('group-descriptions');

        const matchingScoreEl = document.getElementById('matching-score');
        const scoreBarEl = document.getElementById('score-bar');
        const similarityScoreMainEl = document.getElementById('similarity-score-main');
        const preferenceScoreMainEl = document.getElementById('preference-score-main');
        const shapeScoreMainEl = document.getElementById('shape-score-main');
        
        const scoreBreakdownEl = document.getElementById('score-breakdown');
        const similarityBreakdownEl = document.getElementById('similarity-breakdown');
        const preferenceBreakdownEl = document.getElementById('preference-breakdown');

        const maleTarotCardContainer = document.getElementById('male-tarot-card-container');
        const femaleTarotCardContainer = document.getElementById('female-tarot-card-container');
        const tarotCompatibilityText = document.getElementById('tarot-compatibility-text');
        const tarotLoading = document.getElementById('tarot-loading');
        const tarotContent = document.getElementById('tarot-content');


        const resultVisualMaleEl = document.getElementById('result-visual-male');
        const resultProfileTextMaleEl = document.getElementById('result-profile-text-male');
        const resultGroupNameMaleEl = document.getElementById('result-group-name-male');
        const resultGroupDescriptionMaleEl = document.getElementById('result-group-description-male');
        const maleTagsEl = document.getElementById('male-tags');

        const resultVisualFemaleEl = document.getElementById('result-visual-female');
        const resultProfileTextFemaleEl = document.getElementById('result-profile-text-female');
        const resultGroupNameFemaleEl = document.getElementById('result-group-name-female');
        const resultGroupDescriptionFemaleEl = document.getElementById('result-group-description-female');
        const femaleTagsEl = document.getElementById('female-tags');
        
        const relationshipAdviceEl = document.getElementById('relationship-advice');

        let maleRadarChart = null;
        let femaleRadarChart = null;
        let comparisonRadarChart = null;
        let totalExpectedAnswers = 0; // 답변해야 할 총 질문 수
        
        // 질문 유형별 개수 (점수 계산용)
        const questionCounts = {
            similarity: questions.filter(q => q.type === 'similarity').length, // 10
            crossover: questions.filter(q => q.type === 'crossover').length, // 5
            dynamic: questions.filter(q => q.type === 'dynamic').length // 3
        };

        // --- 3. 핵심 유틸 함수 --- (이전 코드와 동일)
        function findTagGroupKey(tag) {
            if (!tag) return null;
            for (const key in tagGroups) {
                if (tagGroups[key].tags.includes(tag)) { return key; }
            }
            return null;
        }
        function getRandomItem(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }
        
        /** 타로 카드 HTML 렌더링 */
        function renderTarotCards(maleGyeol, femaleGyeol) {
            const maleCard = tarotMap[maleGyeol];
            const femaleCard = tarotMap[femaleGyeol];
            
            maleTarotCardContainer.innerHTML = `
                <div class="tarot-card-visual" style="background-image: url('${maleCard.img}');">
                    <div class="tarot-content-overlay">
                        <span class="tarot-card-emoji">${maleCard.emoji}</span>
                        <p class="tarot-card-name">${maleCard.name}</p>
                        <p class="text-xs text-white opacity-90">${sensoryProfiles[maleGyeol].name}</p>
                    </div>
                </div>
            `;

            femaleTarotCardContainer.innerHTML = `
                <div class="tarot-card-visual" style="background-image: url('${femaleCard.img}');">
                    <div class="tarot-content-overlay">
                        <span class="tarot-card-emoji">${femaleCard.emoji}</span>
                        <p class="tarot-card-name">${femaleCard.name}</p>
                        <p class="text-xs text-white opacity-90">${sensoryProfiles[femaleGyeol].name}</p>
                    </div>
                </div>
            `;
            
            // API 호출 대신 내부 데이터베이스에서 리딩 생성 (수정된 부분)
            generateInternalTarotReading(maleGyeol, femaleGyeol);
        }

        /** 내부 데이터베이스 기반 리딩 생성 함수 (NEW) */
        function generateInternalTarotReading(maleGyeol, femaleGyeol) {
            tarotLoading.classList.add('hidden'); // 로딩 숨김
            tarotContent.classList.remove('hidden');

            const key = `${maleGyeol}_${femaleGyeol}`;
            let readings = tarotReadings[key];

            if (!readings) {
                // 역순 조합 확인 (A_B가 없으면 B_A 확인)
                const reverseKey = `${femaleGyeol}_${maleGyeol}`;
                readings = tarotReadings[reverseKey];
            }
            
            if (!readings) {
                // 기본값 사용
                readings = tarotReadings.DEFAULT_READING;
            }

            // 랜덤으로 해석 선택
            const readingText = getRandomItem(readings);
            tarotCompatibilityText.textContent = readingText;
        }

        // --- 4. 질문 렌더링 로직 (이전 코드와 동일) ---
        
        /** 동적 질문 생성 함수 */
        function handleDynamic(radio, qId, gender, followupDataStr) {
            const followupData = JSON.parse(decodeURIComponent(followupDataStr));
            const followupContainerId = `${qId}-${gender}-followup`;
            const questionCard = radio.closest('.question-card');
            
            // 기존의 동적 질문 컨테이너 제거
            const existingFollowup = questionCard.querySelector('.dynamic-followup');
            if (existingFollowup) {
                existingFollowup.remove();
            }

            // 새 동적 질문 컨테이너 생성
            const followupContainer = document.createElement('div');
            followupContainer.id = followupContainerId;
            followupContainer.className = 'dynamic-followup';

            const optionsHTML = followupData.options.map((opt, index) => {
                // 심도(value)에 따라 점수(data-score) 차등 부여 (여기서는 value만 필요)
                let score = 4; // 기본 4점 (심도 3)
                if (opt.value === '1') score = 6; // 심도 1
                else if (opt.value === '2') score = 5; // 심도 2

                return `
                    <input type="radio" name="${qId}-followup-${gender}" value="${opt.value}" id="${qId}-followup-${gender}-${index}" data-score="${score}" class="hidden-radio">
                    <label for="${qId}-followup-${gender}-${index}" class="option-label">
                        ${opt.text}
                    </label>
                `}).join('');

            followupContainer.innerHTML = `
                <p class="font-semibold mb-3 text-gray-800">${followupData.text}</p>
                <div class="space-y-2">${optionsHTML}</div>
            `;
            
            questionCard.appendChild(followupContainer);
        }

        /** 질문 유형 뱃지 HTML */
        function badgeHTML(type) {
            let text = '', color = '';
            if (type === 'similarity') { text = '유사성'; color = 'indigo'; }
            else if (type === 'crossover') { text = '선호성 (교차)'; color = 'pink'; }
            else if (type === 'dynamic') { text = '선호성 (동적)'; color = 'amber'; }
            return `<span class="question-type-badge badge-${type} text-${color}-800 border-${color}-300">${text}</span>`;
        }

        /** 질문 유형에 따라 HTML 생성 */
        function createQuestionHTML(q, gender) {
            let html = '';

            // 공통 옵션 생성기 (메인 질문용)
            const mainOptionsHTML = q.options.map((opt, index) => {
                let onChangeEvent = '';
                if (q.type === 'dynamic') {
                    // JSON 데이터를 문자열로 만들고 URI 인코딩하여 onchange 핸들러에 삽입
                    const followupDataStr = encodeURIComponent(JSON.stringify(opt.followup));
                    onChangeEvent = `onchange="handleDynamic(this, '${q.id}', '${gender}', '${followupDataStr}')"`;
                }
                return `
                    <input type="radio" name="${q.id}-me-${gender}" value="${opt.value}" data-tag="${opt.tag}" id="${q.id}-me-${gender}-${index}" class="hidden-radio" ${onChangeEvent}>
                    <label for="${q.id}-me-${gender}-${index}" class="option-label">
                        ${opt.text}
                    </label>
                `;
            }).join('');

            switch (q.type) {
                case 'similarity':
                    html = `<div class="question-card bg-white rounded-lg shadow-sm border">
                                ${badgeHTML(q.type)}
                                <p class="font-semibold mb-3 text-gray-800">${q.text}</p>
                                <div class="space-y-2">${mainOptionsHTML}</div>
                            </div>`;
                    break;
                case 'crossover':
                    const partnerOptionsHTML = q.options.map((opt, index) => `
                        <input type="radio" name="${q.id}-partner-${gender}" value="${opt.value}" data-tag="${opt.tag}" id="${q.id}-partner-${gender}-${index}" class="hidden-radio">
                        <label for="${q.id}-partner-${gender}-${index}" class="option-label">
                            ${opt.text}
                        </label>
                    `).join('');
                    
                    html = `<div class="question-card bg-white rounded-lg shadow-sm border">
                                ${badgeHTML(q.type)}
                                <div class="space-y-4">
                                    <div>
                                        <p class="font-semibold mb-3 text-gray-800">${q.text_me}</p>
                                        <div class="space-y-2">${mainOptionsHTML}</div>
                                    </div>
                                    <hr class="my-4 border-dashed border-gray-300">
                                    <div>
                                        <p class="font-semibold mb-3 text-gray-800">${q.text_partner}</p>
                                        <div class="space-y-2">${partnerOptionsHTML}</div>
                                    </div>
                                </div>
                            </div>`;
                    break;
                case 'dynamic':
                    html = `<div class="question-card bg-white rounded-lg shadow-sm border">
                                ${badgeHTML(q.type)}
                                <p class="font-semibold mb-3 text-gray-800">${q.text}</p>
                                <div class="space-y-2">${mainOptionsHTML}</div>
                                <!-- 동적 질문은 여기에 삽입됨 -->
                            </div>`;
                    break;
            }
            return html;
        }

        /** 전체 질문 렌더링 */
        function renderQuestions() {
            let maleHTML = '', femaleHTML = '', lastMaleBrainType = '', lastFemaleBrainType = '';
            totalExpectedAnswers = 0; // 총 답변 수 초기화

            questions.forEach(q => {
                if (q.brainType !== lastMaleBrainType) {
                    maleHTML += `<h3 class="brain-type-header male-header">${q.brainType}</h3>`;
                    lastMaleBrainType = q.brainType;
                }
                maleHTML += createQuestionHTML(q, 'male');
                
                if (q.brainType !== lastFemaleBrainType) {
                    femaleHTML += `<h3 class="brain-type-header female-header">${q.brainType}</h3>`;
                    lastFemaleBrainType = q.brainType;
                }
                femaleHTML += createQuestionHTML(q, 'female');

                // 답변해야 할 총 라디오 그룹 수 계산 (남/여 각각)
                if (q.type === 'similarity') totalExpectedAnswers += 1;
                else if (q.type === 'crossover') totalExpectedAnswers += 2;
                else if (q.type === 'dynamic') totalExpectedAnswers += 2; // 'me' 1 + 'followup' 1
            });
            maleQuestionsContainer.innerHTML = maleHTML;
            femaleQuestionsContainer.innerHTML = femaleHTML;
        }

        /** '결' 설명 렌더링 */
        function renderGroupDescriptions() {
            let html = '';
            for (const key in sensoryProfiles) {
                const profile = sensoryProfiles[key];
                const tags = tagGroups[key].tags.join(', ');
                html += `<div class="p-2 bg-white rounded-md border">
                            <p><strong>${profile.name}:</strong> ${profile.description}</p>
                            <p class="mt-1 text-gray-500 text-xs">포함된 태그: ${tags}</p>
                         </div>`;
            }
            groupDescriptionsEl.innerHTML = html;
        }
        
        // --- 5. 차트 생성 함수 ---
        function generateProfile(groupKey) {
            const profileWords = sensoryWords[groupKey];
            const texture = getRandomItem(profileWords.texture);
            const color = getRandomItem(profileWords.color);
            const scent = getRandomItem(profileWords.scent);
            const shape = getRandomItem(profileWords.shape);
            return `${texture} ${color} ${scent}의 ${shape}`;
        }

        function createRadarChart(canvasId, label, data, color) {
            const ctx = document.getElementById(canvasId).getContext('2d');
             if (window[canvasId + 'ChartInstance']) { window[canvasId + 'ChartInstance'].destroy(); }
            const chartData = {
                labels: Object.values(sensoryProfiles).map(p => p.name.split(' ')[0]),
                datasets: [{
                    label: label,
                    data: Object.keys(sensoryProfiles).map(key => data[key] || 0),
                    backgroundColor: `rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.2)`,
                    borderColor: color,
                    pointBackgroundColor: color,
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: color
                }]
            };
            const options = {
                scales: { 
                    r: { 
                        angleLines: { display: true }, 
                        suggestedMin: 0, 
                        suggestedMax: Math.max(...Object.values(data), 5), // 최대값 보정
                        pointLabels: { fontSize: 14 } // 레이블 폰트 크기
                    } 
                },
                plugins: { legend: { position: 'bottom', } }
            };
             window[canvasId + 'ChartInstance'] = new Chart(ctx, { type: 'radar', data: chartData, options: options });
             return window[canvasId + 'ChartInstance'];
        }

        function createComparisonRadarChart(canvasId, maleData, femaleData) {
             const ctx = document.getElementById(canvasId).getContext('2d');
             if (window[canvasId + 'ChartInstance']) { window[canvasId + 'ChartInstance'].destroy(); }
             const chartData = {
                labels: Object.values(sensoryProfiles).map(p => p.name.split(' ')[0]),
                datasets: [
                    {
                        label: '남자',
                        data: Object.keys(sensoryProfiles).map(key => maleData[key] || 0),
                        backgroundColor: 'rgba(59, 130, 246, 0.2)', borderColor: '#3B82F6', pointBackgroundColor: '#3B82F6',
                        pointBorderColor: '#fff', pointHoverBackgroundColor: '#fff', pointHoverBorderColor: '#3B82F6'
                    }, 
                     {
                        label: '여자',
                        data: Object.keys(sensoryProfiles).map(key => femaleData[key] || 0),
                        backgroundColor: 'rgba(236, 72, 153, 0.2)', borderColor: '#EC4899', pointBackgroundColor: '#EC4899',
                        pointBorderColor: '#fff', pointHoverBackgroundColor: '#fff', pointHoverBorderColor: '#EC4899'
                    }
                ]
            };
            const options = {
                 scales: { 
                    r: { 
                        angleLines: { display: true }, 
                        suggestedMin: 0, 
                        suggestedMax: Math.max(...Object.values(maleData), ...Object.values(femaleData), 5), // 최대값 보정
                        pointLabels: { fontSize: 14 } // 레이블 폰트 크기
                    } 
                 }, 
                 plugins: { legend: { position: 'bottom', } }
            };
            window[canvasId + 'ChartInstance'] = new Chart(ctx, { type: 'radar', data: chartData, options: options });
            return window[canvasId + 'ChartInstance'];
        }
        
        /** '결 모양 점수' 계산 함수 (유클리드 거리 기반 유사도) */
        function calculateShapeSimilarity(maleCounts, femaleCounts) {
            let sumOfSquares = 0;
            const keys = Object.keys(sensoryProfiles);
            const totalQuestionsCount = questions.length; // 18
            const maxCounts = Math.max(totalQuestionsCount, 1); // 최대 카운트 (정규화용)

            for (const key of keys) {
                const maleScore = (maleCounts[key] || 0) / maxCounts; // 0-1 정규화
                const femaleScore = (femaleCounts[key] || 0) / maxCounts; // 0-1 정규화
                sumOfSquares += Math.pow(maleScore - femaleScore, 2);
            }

            const distance = Math.sqrt(sumOfSquares);
            const maxDistance = Math.sqrt(keys.length); // 최대 가능한 거리
            const similarity = 1 - (distance / maxDistance); // 0 (다름) ~ 1 (같음)
            
            return similarity; // 0 ~ 1 사이의 값
        }

        // --- 6. 결과 계산 로직 (100점 만점: 결 70 + 유사성 15 + 선호성 15) ---
        function calculateResults() {
            // 답변 완료 여부 확인
            const maleAnsweredCount = document.querySelectorAll('#male-questions input:checked').length;
            const femaleAnsweredCount = document.querySelectorAll('#female-questions input:checked');
            if (maleAnsweredCount < totalExpectedAnswers || femaleAnsweredCount.length < totalExpectedAnswers) {
                warningMessage.classList.remove('hidden');
                return;
            }
            warningMessage.classList.add('hidden');

            let rawSimilarityScore = 0;
            const maxRawSimilarityScore = 40; // (3*4) + (4*4) + (3*4) = 40 (Q list: 10 Sim Qs)
            
            let rawPreferenceScore = 0;
            const maxRawPreferenceScore = 116; // (5*16) + (3*12) = 116 (Q list: 5 Cross, 3 Dynamic)

            
            // --- 세부 항목 점수 초기화 ---
            let simSubScores = { action: 0, emotion: 0, thinking: 0 };
            const maxSimSubScores = { action: 12, emotion: 16, thinking: 12 }; // Total 40

            let prefSubScores = { cross_emotion: 0, cross_thinking: 0, dynamic_thinking: 0 };
            const maxPrefSubScores = { cross_emotion: 32, cross_thinking: 48, dynamic_thinking: 36 }; // Total 116
            
            const maleTags = {}, femaleTags = {}, maleGroupCounts = {}, femaleGroupCounts = {};
            const maleMeNodes = {}, femaleMeNodes = {}; // '나의' 답변 노드 저장                        
            
            // 1. '나의' 답변 및 성향 집계 (모든 질문 루프)
            questions.forEach((q) => {
                const maleMeNodeCorrected = document.querySelector(`input[name="${q.id}-me-male"]:checked`);
                const femaleMeNodeCorrected = document.querySelector(`input[name="${q.id}-me-female"]:checked`);

                maleMeNodes[q.id] = maleMeNodeCorrected; // 나중 비교를 위해 저장
                femaleMeNodes[q.id] = femaleMeNodeCorrected; // 나중 비교를 위해 저장

                const maleMeTag = maleMeNodeCorrected ? maleMeNodeCorrected.dataset.tag : null;
                const femaleMeTag = femaleMeNodeCorrected ? femaleMeNodeCorrected.dataset.tag : null;
                
                // '나의' 답변 태그 카운트 (성향 분석용)
                if (maleMeTag) {
                    maleTags[maleMeTag] = (maleTags[maleMeTag] || 0) + 1;
                    const maleGroupKey = findTagGroupKey(maleMeTag);
                    if(maleGroupKey) maleGroupCounts[maleGroupKey] = (maleGroupCounts[maleGroupKey] || 0) + 1;
                }
                if (femaleMeTag) {
                    femaleTags[femaleMeTag] = (femaleTags[femaleMeTag] || 0) + 1;
                    const femaleGroupKey = findTagGroupKey(femaleMeTag);
                    if(femaleGroupKey) femaleGroupCounts[femaleGroupKey] = (femaleGroupCounts[femaleGroupKey] || 0) + 1;
                }
            });
            
            // 2. '결' 모양 점수 계산 (최대 70점)
            const SHAPE_SCALE = 70;
            const shapeSimilarity = calculateShapeSimilarity(maleGroupCounts, femaleGroupCounts); // 0 ~ 1 (0% ~ 100%)
            const shapeScore = shapeSimilarity * SHAPE_SCALE; // Max 70점

            // 3. '유사성'/'선호성' 원점수 계산 (세부 항목 분리)
            questions.forEach((q) => {
                const maleMeNode = maleMeNodes[q.id];
                const femaleMeNode = femaleMeNodes[q.id];
                const maleMeTag = maleMeNode.dataset.tag;
                const femaleMeTag = femaleMeNode.dataset.tag;
                const maleGroupKey = findTagGroupKey(maleMeTag);
                const femaleGroupKey = findTagGroupKey(femaleMeTag);
                
                let currentRawScore = 0;
                let subCategory = '';

                if (q.type === 'similarity') {
                    if (maleMeNode.value === femaleMeNode.value) {
                        currentRawScore = 4; // 완전 일치
                    } else if (maleGroupKey && maleGroupKey === femaleGroupKey) {
                        currentRawScore = 3; // 성향('결') 일치
                    }
                    rawSimilarityScore += currentRawScore; // 총합
                    
                    if (['q1', 'q2', 'q22'].includes(q.id)) subCategory = 'action';
                    else if (['q23', 'q26', 'q17', 'q18'].includes(q.id)) subCategory = 'emotion';
                    else if (['q11', 'q12', 'q15'].includes(q.id)) subCategory = 'thinking';
                    
                    if (subCategory) simSubScores[subCategory] += currentRawScore;

                } else if (q.type === 'crossover') {
                    const malePartnerNode = document.querySelector(`input[name="${q.id}-partner-male"]:checked`);
                    const femalePartnerNode = document.querySelector(`input[name="${q.id}-partner-female"]:checked`);
                    const malePartnerTag = malePartnerNode ? malePartnerNode.dataset.tag : null;
                    const femalePartnerTag = femalePartnerNode ? femalePartnerNode.dataset.tag : null;
                    const malePartnerGroup = findTagGroupKey(malePartnerTag);
                    const femalePartnerGroup = findTagGroupKey(femalePartnerTag);
                    
                    let crossScore = 0;

                    // 남자가 원하는 파트너 모습 <-> 여자의 실제 모습
                    if (malePartnerNode.value === femaleMeNode.value) {
                        crossScore += 8; // 완전 일치
                    } else if (malePartnerGroup && malePartnerGroup === femaleGroupKey) {
                        crossScore += 4; // 성향('결') 일치
                    }
                    
                    // 여자가 원하는 파트너 모습 <-> 남자의 실제 모습
                    if (femalePartnerNode.value === maleMeNode.value) {
                        crossScore += 8; // 완전 일치
                    } else if (femalePartnerGroup && femalePartnerGroup === maleGroupKey) {
                        crossScore += 4; // 성향('결') 일치
                    }
                    
                    rawPreferenceScore += crossScore; // 총합
                    
                    if (['q4', 'q5'].includes(q.id)) subCategory = 'cross_emotion';
                    else if (['q19', 'q24', 'q13'].includes(q.id)) subCategory = 'cross_thinking';

                    if (subCategory) prefSubScores[subCategory] += crossScore;

                } else if (q.type === 'dynamic') {
                    const maleFollowupNode = document.querySelector(`input[name="${q.id}-followup-male"]:checked`);
                    const femaleFollowupNode = document.querySelector(`input[name="${q.id}-followup-female"]:checked`);
                    // data-score는 해당 옵션의 심도 점수 (6, 5, 4)
                    const maleFollowupScore = maleFollowupNode ? parseInt(maleFollowupNode.dataset.score, 10) : 0;
                    const femaleFollowupScore = femaleFollowupNode ? parseInt(femaleFollowupNode.dataset.score, 10) : 0;
                    
                    let dynamicScore = 0;
                    
                    // 남자의 선호(Followup Value)가 여자의 실제 답변(Me Value)과 일치하는 경우
                    if (maleFollowupNode.value === femaleMeNode.value) {
                        dynamicScore += maleFollowupScore; // 심도별 차등 점수
                    } else if (maleFollowupNode.value === 'any') {
                        dynamicScore += 4; // 'any'는 4점으로 고정
                    }
                    
                    // 여자의 선호(Followup Value)가 남자의 실제 답변(Me Value)과 일치하는 경우
                    if (femaleFollowupNode.value === maleMeNode.value) {
                        dynamicScore += femaleFollowupScore; // 심도별 차등 점수
                    } else if (femaleFollowupNode.value === 'any') {
                        dynamicScore += 4;
                    }

                    rawPreferenceScore += dynamicScore; // 총합
                    prefSubScores.dynamic_thinking += dynamicScore;
                }
            });


            // 4. 최종 점수 환산 (70 / 15 / 15)
            const SIMILARITY_SCALE = 15;
            const PREFERENCE_SCALE = 15;
            
            // 메인 점수 환산 (총점 합산에 사용)
            const finalSimilarityScore = maxRawSimilarityScore > 0 ? (rawSimilarityScore / maxRawSimilarityScore) * SIMILARITY_SCALE : 0;
            const finalPreferenceScore = maxRawPreferenceScore > 0 ? (rawPreferenceScore / maxRawPreferenceScore) * PREFERENCE_SCALE : 0;
            
            // 5. 최종 총점 계산 (Max 100점)
            const totalScore = shapeScore + finalSimilarityScore + finalPreferenceScore;
            
            
            // --- 7. 결과 표시 로직 ---
            
            // 점수 DOM 업데이트
            const displayTotalScore = Math.round(totalScore);
            matchingScoreEl.textContent = `${displayTotalScore}점`;
            scoreBarEl.style.width = `${Math.min(100, displayTotalScore)}%`; 
            
            // 메인 점수 표시 (100점 만점 환산 점수, 소수점 첫째 자리까지 표시)
            const displaySim100 = maxRawSimilarityScore > 0 ? (rawSimilarityScore / maxRawSimilarityScore) * 100 : 0;
            const displayPref100 = maxRawPreferenceScore > 0 ? (rawPreferenceScore / maxRawPreferenceScore) * 100 : 0;
            const displayShape100 = shapeSimilarity * 100; // 0~1 값을 0~100으로 환산
            
            shapeScoreMainEl.textContent = `${displayShape100.toFixed(1)}점`; // Max 100 (UI 표기용)
            similarityScoreMainEl.textContent = `${displaySim100.toFixed(1)}점`; // Max 100
            preferenceScoreMainEl.textContent = `${displayPref100.toFixed(1)}점`; // Max 100
            
            // --- 상세 항목 점수 렌더링 (수정됨: 원점수 대신 환산 점수 표시) ---
            const renderSubScore = (score, max, title, color) => {
                const score100 = max > 0 ? (score / max) * 100 : 0;
                const score100Fixed = score100.toFixed(1);
                const max100 = 100; // 모든 항목 100점 만점
                
                // 괄호 안의 점수도 100점 만점 기준으로 환산된 점수를 표시
                return `<div class="flex justify-between items-center text-sm">
                            <span class="font-medium text-gray-700">${title}</span>
                            <div class="flex items-center space-x-2">
                                <div class="w-20 bg-gray-200 rounded-full h-2">
                                    <div class="bg-${color}-500 h-2 rounded-full" style="width: ${score100}%;"></div>
                                </div>
                                <span class="font-bold text-${color}-600">${score100Fixed}점</span>
                                <span class="text-xs text-gray-500">(${score100Fixed} / ${max100}점)</span>
                            </div>
                        </div>`;
            };

            // 7.1 유사성 상세
            const simBreakdownHTML = [
                renderSubScore(simSubScores.action, maxSimSubScores.action, '행동 유사성', 'blue'),
                renderSubScore(simSubScores.emotion, maxSimSubScores.emotion, '관계 유사성', 'blue'),
                renderSubScore(simSubScores.thinking, maxSimSubScores.thinking, '가치관 유사성', 'blue')
            ].join('');
            similarityBreakdownEl.innerHTML = simBreakdownHTML;

            // 7.2 선호성 상세
            const prefBreakdownHTML = [
                renderSubScore(prefSubScores.cross_emotion, maxPrefSubScores.cross_emotion, '교차 선호: 관계', 'pink'),
                renderSubScore(prefSubScores.cross_thinking, maxPrefSubScores.cross_thinking, '교차 선호: 가치관', 'pink'),
                renderSubScore(prefSubScores.dynamic_thinking, maxPrefSubScores.dynamic_thinking, '동적 선호: 심도', 'pink')
            ].join('');
            preferenceBreakdownEl.innerHTML = prefBreakdownHTML;


            // 차트 영역은 DOM에 이미 있으므로, 차트 인스턴스만 다시 생성
            maleRadarChart = createRadarChart('maleRadarChart', '남자', maleGroupCounts, '#3B82F6');
            femaleRadarChart = createRadarChart('femaleRadarChart', '여자', femaleGroupCounts, '#EC4899');
            comparisonRadarChart = createComparisonRadarChart('comparisonRadarChart', maleGroupCounts, femaleGroupCounts);

            // 프로필 생성
            const dominantMaleGroupKey = Object.keys(maleGroupCounts).length > 0 ? Object.keys(maleGroupCounts).reduce((a, b) => maleGroupCounts[a] > maleGroupCounts[b] ? a : b) : 'ADAPTIVE_BALANCED';
            const dominantFemaleGroupKey = Object.keys(femaleGroupCounts).length > 0 ? Object.keys(femaleGroupCounts).reduce((a, b) => femaleGroupCounts[a] > femaleGroupCounts[b] ? a : b) : 'ADAPTIVE_BALANCED';
            const maleProfileData = sensoryProfiles[dominantMaleGroupKey];
            const femaleProfileData = sensoryProfiles[dominantFemaleGroupKey];
            combinedGradientEl.style.background = `linear-gradient(to right, ${maleProfileData.colorCode}, ${femaleProfileData.colorCode})`;
            resultVisualMaleEl.className = `mt-4 p-6 rounded-lg transition-all duration-500 ${maleProfileData.background}`;
            resultProfileTextMaleEl.textContent = generateProfile(dominantMaleGroupKey);
            resultGroupNameMaleEl.textContent = `남자는 '${maleProfileData.name}'`;
            resultGroupDescriptionMaleEl.textContent = maleProfileData.description;
            maleTagsEl.innerHTML = Object.entries(maleTags).sort((a, b) => b[1] - a[1]).map(([tag, count]) => `<span class="result-tag font-medium py-1 px-3 rounded-full text-sm">${tag}${count > 1 ? ` x${count}` : ''}</span>`).join('');
            resultVisualFemaleEl.className = `mt-4 p-6 rounded-lg transition-all duration-500 ${femaleProfileData.background}`;
            resultProfileTextFemaleEl.textContent = generateProfile(dominantFemaleGroupKey);
            resultGroupNameFemaleEl.textContent = `여자는 '${femaleProfileData.name}'`;
            resultGroupDescriptionFemaleEl.textContent = femaleProfileData.description;
            femaleTagsEl.innerHTML = Object.entries(femaleTags).sort((a, b) => b[1] - a[1]).map(([tag, count]) => `<span class="result-tag font-medium py-1 px-3 rounded-full text-sm">${tag}${count > 1 ? ` x${count}` : ''}</span>`).join('');

            // --- 타로 카드 렌더링 및 API 호출 ---
            renderTarotCards(dominantMaleGroupKey, dominantFemaleGroupKey);
            
            // --- 관계 조언 로직 ---
            const displayShapeScoreFinal = Math.round(shapeScore);
            const displaySimilarityScoreFinal = Math.round(finalSimilarityScore);
            const displayPreferenceScoreFinal = Math.round(finalPreferenceScore);
            
            let advice = '';
            if (displayTotalScore > 85) {
                advice = `총점 ${displayTotalScore}점! (최고!) '결' 모양 점수(${displayShapeScoreFinal}점)가 매우 높고, 보너스 점수까지 훌륭합니다. 두 분은 핵심 성향이 매우 비슷하고 서로를 잘 이해하는 천생연분입니다!`;
            } else if (displayTotalScore > 65) {
                 advice = `좋은 점수(${displayTotalScore}점)입니다! 두 분의 '결' 모양 점수(${displayShapeScoreFinal}점)가 높아 근본적으로 잘 맞는 성향입니다. '유사성'(${displaySimilarityScoreFinal}점)과 '선호성'(${displayPreferenceScoreFinal}점) 점수를 확인하며 서로를 더 알아가보세요.`;
            } else if (displayTotalScore > 45) {
                 advice = `괜찮은 점수(${displayTotalScore}점)입니다. '결' 모양 점수(${displayShapeScoreFinal}점)가 조금 낮더라도, '선호성' 점수(${displayPreferenceScoreFinal}점)가 높다면 서로의 다름을 존중하고 맞춰가고 있다는 의미입니다.`;
            } else {
                advice = `두 분은 서로 다른 '결'을 가졌습니다 (총점 ${displayTotalScore}점). 하지만 이것은 성장의 기회가 될 수 있습니다. 서로의 '결'을 존중하고 '선호성' 점수(${displayPreferenceScoreFinal}점)를 올리기 위해 노력해보세요!`;
            }
            if (dominantMaleGroupKey === dominantFemaleGroupKey) { 
                 advice += ` (두 분은 '${maleProfileData.name}'(으)로 핵심 '결'이 동일합니다.)`;
            } else { 
                 advice += ` (두 분은 각각 '${maleProfileData.name}', '${femaleProfileData.name}'(으)로 서로 다른 '결'을 가졌지만, 이 다름이 서로의 세계를 넓혀줄 수 있습니다.)`;
            }
            relationshipAdviceEl.textContent = advice;
            // --- 관계 조언 수정 완료 ---


            questionSection.classList.add('hidden');
            resultsContainer.classList.remove('hidden');
            document.querySelectorAll('#results .fade-in').forEach(el => el.style.opacity = 0);
            setTimeout(() => {
                 document.querySelectorAll('#results .fade-in').forEach(el => el.classList.add('is-visible'));
            }, 10);
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // --- 8. 이벤트 리스너 ---
        retryBtn.addEventListener('click', () => {
            if (maleRadarChart) maleRadarChart.destroy();
            if (femaleRadarChart) femaleRadarChart.destroy();
            if (comparisonRadarChart) comparisonRadarChart.destroy();
            resultsContainer.classList.add('hidden');
            questionSection.classList.remove('hidden');
            // 질문 다시 렌더링 (동적 질문 초기화를 위해)
            renderQuestions(); 
            // 타로 섹션 초기화
            tarotLoading.classList.add('hidden');
            tarotContent.classList.remove('hidden'); // 컨텐츠는 초기화 시 보임 상태로 시작 (데이터는 없지만)
            tarotCompatibilityText.textContent = '';
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        /** 랜덤 답변 버튼 리스너 */
        randomBtn.addEventListener('click', () => {
            ['male', 'female'].forEach(gender => {
                questions.forEach(q => {
                    // 1. '나의' 질문에 랜덤 답변
                    const meRadios = document.querySelectorAll(`input[name="${q.id}-me-${gender}"]`);
                    if (meRadios.length > 0) {
                        const randomMeRadio = meRadios[Math.floor(Math.random() * meRadios.length)];
                        randomMeRadio.checked = true;
                        // 동적 질문 트리거를 위해 'change' 이벤트 강제 발생
                        randomMeRadio.dispatchEvent(new Event('change', { bubbles: true }));
                    }

                    // 2. '파트너' 질문(Crossover)에 랜덤 답변
                    if (q.type === 'crossover') {
                        const partnerRadios = document.querySelectorAll(`input[name="${q.id}-partner-${gender}"]`);
                         if (partnerRadios.length > 0) {
                            partnerRadios[Math.floor(Math.random() * partnerRadios.length)].checked = true;
                        }
                    }
                });
            });

            // 3. '동적' 질문에 랜덤 답변 (이벤트 발생 후 잠시 기다렸다가 실행)
            setTimeout(() => {
                ['male', 'female'].forEach(gender => {
                    questions.forEach(q => {
                        if (q.type === 'dynamic') {
                            const followupRadios = document.querySelectorAll(`input[name="${q.id}-followup-${gender}"]`);
                            if (followupRadios.length > 0) {
                                followupRadios[Math.floor(Math.random() * followupRadios.length)].checked = true;
                            }
                        }
                    });
                });
            }, 100); // 동적 질문이 렌더링될 시간 확보
        });

        calculateBtn.addEventListener('click', calculateResults);

        // --- 9. 초기 실행 ---
        renderQuestions();
        renderGroupDescriptions();
    </script>
</body>
</html>
